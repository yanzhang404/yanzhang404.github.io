<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcode_day14</title>
    <link href="/2023/12/14/leetcode-day14/"/>
    <url>/2023/12/14/leetcode-day14/</url>
    
    <content type="html"><![CDATA[<h2 id="最长有效括号-32"><a href="#最长有效括号-32" class="headerlink" title="最长有效括号(32)"></a>最长有效括号(<a href="https://leetcode.cn/problems/longest-valid-parentheses/description/">32</a>)</h2><p>依然是利用括号匹配的两个原则，1，任意前缀中 “(“ &gt; “)”，”(“  == “)”。</p><p>我们可以将序列分段。当出现第一个右括号多于左括号的位置时，后面就不会出现匹配的序列了。</p><p>因此求出这一段中的最长有效括号序列，然后更新段的起点。继续做相同的事。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st; <span class="hljs-comment">// 存放左括号的下标</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">//start代表这一段开始的上一个位置，所以从-1开始。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, start = <span class="hljs-number">-1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-comment">//左括号就入栈</span><br>          <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>              <span class="hljs-comment">//如果栈非空，说明有匹配的，先弹出元素代表匹配</span><br>                <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">size</span>())&#123;<br>                    st.<span class="hljs-built_in">pop</span>();<br>                  <span class="hljs-comment">//此时还有左括号，说明从这个左括号往右的都是匹配的，可以求一下res</span><br>                    <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">size</span>())&#123;<br>                        res = <span class="hljs-built_in">max</span>(res, i - st.<span class="hljs-built_in">top</span>());<br>                    &#125;<br>                  <span class="hljs-comment">//如果空了，说明到顶了，全部匹配完了。直接与开始位置相减</span><br>                    <span class="hljs-keyword">else</span>&#123;<br>                        res = <span class="hljs-built_in">max</span>(res, i - start);<br>                    &#125;<br>                &#125;<br>              <span class="hljs-comment">//栈空代表没有左括号和右括号匹配，所以这一段结束</span><br>                <span class="hljs-keyword">else</span>&#123;<br>                  <span class="hljs-comment">//将这个多余的右括号的位置更新为新的start</span><br>                        start = i;<br>                    &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树前序遍历-144"><a href="#二叉树前序遍历-144" class="headerlink" title="二叉树前序遍历(144)"></a>二叉树前序遍历(<a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">144</a>)</h2><p>简单题</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)   <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>            <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树的最大深度-104"><a href="#二叉树的最大深度-104" class="headerlink" title="二叉树的最大深度(104)"></a>二叉树的最大深度(<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104</a>)</h2><p>递归求左右子树的深度，取最大+1.</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(root-&gt;left),<span class="hljs-built_in">dfs</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="平衡二叉树-110"><a href="#平衡二叉树-110" class="headerlink" title="平衡二叉树(110)"></a>平衡二叉树(<a href="https://leetcode.cn/problems/balanced-binary-tree/description/">110</a>)</h2><p>根据题意求解即可。</p><p>也可设立一个bool类型的全局变量。</p><p>在计算高度的时候顺便判断true or false。这个想法也不错。</p><p>我是写了两个递归。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">treeHeight</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">treeHeight</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(left - right) &lt;= <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="hljs-built_in">isBalanced</span>(root-&gt;right))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">treeHeight</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">treeHeight</span>(root-&gt;left),<span class="hljs-built_in">treeHeight</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个耗时可能低一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">bool</span> ans;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        ans = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> lh = <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> rh = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(lh - rh) &gt; <span class="hljs-number">1</span>)    ans = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(lh, rh) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day13</title>
    <link href="/2023/12/13/leetcode-day13/"/>
    <url>/2023/12/13/leetcode-day13/</url>
    
    <content type="html"><![CDATA[<h2 id="从前序与中序遍历序列构造二叉树-105"><a href="#从前序与中序遍历序列构造二叉树-105" class="headerlink" title="从前序与中序遍历序列构造二叉树(105)"></a>从前序与中序遍历序列构造二叉树(<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">105</a>)</h2><p>主要就是用hash表存一下inorder里每个点的位置，然后每次根据preorder找到root在inorder里的位置，将序列分为两个区间，再递归构造二叉树。关键是需要一个额外的函数去实现这个递归过程，因为要传入参数之类的。</p><span id="more"></span><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-comment">//把每个数在这之间的位置找到</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            hash[inorder[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(preorder,inorder,<span class="hljs-number">0</span>,preorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br><br>  <span class="hljs-comment">//要传入这个序列的起始位置和结束位置。</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder,vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> pl, <span class="hljs-type">int</span> pr, <span class="hljs-type">int</span> il, <span class="hljs-type">int</span> ir)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(pl &gt; pr) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[pl]);<br>        <span class="hljs-type">int</span> k = hash[root-&gt;val];<br>        root-&gt;left = <span class="hljs-built_in">build</span>(preorder, inorder, pl + <span class="hljs-number">1</span>, pl + <span class="hljs-number">1</span> + k - <span class="hljs-number">1</span> - il, il, k - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(preorder, inorder, pl + <span class="hljs-number">1</span> + k - <span class="hljs-number">1</span> - il + <span class="hljs-number">1</span>, pr, k + <span class="hljs-number">1</span>, ir);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="零钱兑换-322"><a href="#零钱兑换-322" class="headerlink" title="零钱兑换(322)"></a>零钱兑换(<a href="https://leetcode.cn/problems/coin-change/description/">322</a>)</h2><p>是一个完全背包问题，要学会转换。不能用贪心，因为面额的大小不标准。</p><p>只能用dp来做。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//完全背包问题。</span><br>    <span class="hljs-comment">//面额看作体积，有无数个，value是个数， m是背包容量</span><br>    <span class="hljs-comment">//装满背包的最少个数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(m+<span class="hljs-number">1</span>, <span class="hljs-number">1e8</span>)</span></span>;<br>      <span class="hljs-comment">//体积为i的情况下，需要的硬币最少是多少。</span><br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : coins)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt;= m; j++)&#123;<br>                f[j] = <span class="hljs-built_in">min</span>(f[j],f[j - i] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(f[m] == <span class="hljs-number">1e8</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> f[m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最小栈-155"><a href="#最小栈-155" class="headerlink" title="最小栈(155)"></a>最小栈(<a href="https://leetcode.cn/problems/min-stack/description/">155</a>)</h2><p>用一个栈来存数，再用一个栈来存最小的数，每次如果要加进来的数&lt;=栈顶元素，就加入这个最小栈里。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; st;<br>    stack&lt;<span class="hljs-type">int</span>&gt; min_st;<br>    <span class="hljs-built_in">MinStack</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        st.<span class="hljs-built_in">push</span>(val);<br>        <span class="hljs-keyword">if</span>(!min_st.<span class="hljs-built_in">size</span>() || val &lt;= min_st.<span class="hljs-built_in">top</span>())&#123;<br>            min_st.<span class="hljs-built_in">push</span>(val);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">top</span>() == min_st.<span class="hljs-built_in">top</span>())&#123;<br>            st.<span class="hljs-built_in">pop</span>();<br>            min_st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span>    st.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> min_st.<span class="hljs-built_in">top</span>();<br><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="反转字符串中的单词-151"><a href="#反转字符串中的单词-151" class="headerlink" title="反转字符串中的单词(151)"></a>反转字符串中的单词(<a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151</a>)</h2><p>我先定义了新的字符串res，然后双指针去遍历，每次将单词加到新的字符串里，</p><p>但是这样开辟了新的空间，如果想满足O(1)的空间复杂度，我们可以先将每个单词反转，再将整个字符串反转，这样是在原字符串上操作，不会开辟额外的空间。</p><p>对于有空格的，我们只需要每次将单词前移。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> j = i, t = k;<br>            <span class="hljs-keyword">while</span>(j &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[j] != <span class="hljs-string">&#x27; &#x27;</span>)  s[t++] = s[j++];<br>            i = j;<br>            <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + k,s.<span class="hljs-built_in">begin</span>() + t);<br>            s[t++] = <span class="hljs-string">&#x27; &#x27;</span>;<br>            k = t;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k) k--;<br>        s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>() + k, s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="字符串相乘-43"><a href="#字符串相乘-43" class="headerlink" title="字符串相乘(43)"></a>字符串相乘(<a href="https://leetcode.cn/problems/multiply-strings/description/">43</a>)</h2><p>复习竖式计算，但我们不需要每次计算的时候进位，我们可以先将每次相乘的数记下来，最后一起往前进位。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">multiply</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; A, B;<br>        <span class="hljs-type">int</span> n = num1.<span class="hljs-built_in">size</span>(), m = num2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)  A.<span class="hljs-built_in">push_back</span>(num1[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)  B.<span class="hljs-built_in">push_back</span>(num2[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">C</span><span class="hljs-params">(n+m)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>              <span class="hljs-comment">//每次记录的位置就是i+j</span><br>                C[i+j] += A[i]*B[j];<br>            &#125;<br>        &#125;<br>        string res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, carry = <span class="hljs-number">0</span>; i &lt; C.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            carry += C[i];<br>            C[i] = carry % <span class="hljs-number">10</span>;<br>            carry = carry / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> k = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>( k &gt; <span class="hljs-number">0</span> &amp;&amp; C[k] == <span class="hljs-number">0</span>)  k--;<br><br>        <span class="hljs-keyword">while</span>(k &gt;=<span class="hljs-number">0</span>)    res += C[k--]+<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UCB_CS186</title>
    <link href="/2023/12/12/UCBCS186_note/"/>
    <url>/2023/12/12/UCBCS186_note/</url>
    
    <content type="html"><![CDATA[<h1 id="UCB-CS186"><a href="#UCB-CS186" class="headerlink" title="UCB_CS186"></a>UCB_CS186</h1><p>take some note on the lesson, and record the project in this markdown.</p><p>project2 implement:<a href="https://github.com/yanzhang404/cs186.git">My implement</a></p><p>reference:<a href="https://github.com/mag1cianag/UCB-CS186">https://github.com/mag1cianag/UCB-CS186</a></p><h1 id="DATABASE-0-intro"><a href="#DATABASE-0-intro" class="headerlink" title="DATABASE-0-intro"></a>DATABASE-0-intro</h1><h2 id="Database-System"><a href="#Database-System" class="headerlink" title="Database System"></a>Database System</h2><p>System for providing EFFICIENT,CONVENIENT,SAFE, MULTI_USER storage of and access ti NASSIIVE amounts of PERSISTENT data</p><p><img src="https://raw.githubusercontent.com/yanzhang404/Image/main/%E6%88%AA%E5%B1%8F2023-12-03%2023.12.24.png" alt="截屏2023-12-03 23.12.24"></p><p><img src="https://raw.githubusercontent.com/yanzhang404/Image/main/%E6%88%AA%E5%B1%8F2023-12-03%2023.12.35.png" alt="截屏2023-12-03 23.12.35"></p><h1 id="project-1"><a href="#project-1" class="headerlink" title="project_1"></a>project_1</h1><p>just follow the step in project-gitbook,we can get it from github</p><p>as we download the lahman.db, we can use sqlite3 to view the database.</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">sqlite3 lahman<span class="hljs-meta">.db</span><br><br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="Your-Tasks"><a href="#Your-Tasks" class="headerlink" title="Your Tasks"></a>Your Tasks</h2><h3 id="Task-2-Hall-of-Fame-Schools"><a href="#Task-2-Hall-of-Fame-Schools" class="headerlink" title="Task 2: Hall of Fame Schools"></a>Task 2: <strong>Hall of Fame Schools</strong></h3><p><strong>i.</strong> Find the <code>namefirst</code>, <code>namelast</code>, <code>playerid</code> and <code>yearid</code> of all people who were successfully inducted into the Hall of Fame in _descending_ order of <code>yearid</code>. Break ties on <code>yearid</code> by <code>playerid</code> (ascending).</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> namefirst,namelast,people.playerid,halloffame.yearid <br><span class="hljs-keyword">FROM</span> people<br><span class="hljs-keyword">JOIN</span> halloffame <span class="hljs-keyword">ON</span> people.playerid <span class="hljs-operator">=</span> halloffame.playerid<br><span class="hljs-keyword">WHERE</span> inducted <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Y&#x27;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> yearid <span class="hljs-keyword">DESC</span>, people.playerid <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure><p><strong>ii.</strong> Find the people who were successfully inducted into the Hall of Fame and played in college at a school located in the state of California. For each person, return their <code>namefirst</code>, <code>namelast</code>, <code>playerid</code>, <code>schoolid</code>, and <code>yearid</code> in _descending_ order of <code>yearid</code>. Break ties on <code>yearid</code> by <code>schoolid, playerid</code> (ascending). For this question, <code>yearid</code> refers to the year of induction into the Hall of Fame.</p><p>首先这个人要在halloffame里，有一个collageplaying table, 一个schools表，我先找到学校在CA的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> A.namefirst, A.namelast, A.playerid, B.schoolID, A.yearid<br><span class="hljs-keyword">FROM</span> q2i <span class="hljs-keyword">AS</span> A<br><span class="hljs-keyword">JOIN</span> (<br>    <span class="hljs-keyword">SELECT</span> playerID, <span class="hljs-keyword">year</span>, schools.schoolID<br>    <span class="hljs-keyword">FROM</span> collegeplaying<br>    <span class="hljs-keyword">JOIN</span> schools <span class="hljs-keyword">ON</span> collegeplaying.schoolID <span class="hljs-operator">=</span> schools.schoolID<br>    <span class="hljs-keyword">WHERE</span> schools.schoolState <span class="hljs-operator">=</span> &quot;CA&quot;<br>) <span class="hljs-keyword">AS</span> B <span class="hljs-keyword">ON</span> A.playerid <span class="hljs-operator">=</span> B.playerID  #通过playerid连接<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> A.yearid <span class="hljs-keyword">DESC</span>, B.schoolID <span class="hljs-keyword">ASC</span>, A.playerid <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure><ul><li>Note: a player may appear in the results multiple times (once per year in a college in California).</li></ul><p><strong>iii.</strong> Find the <code>playerid</code>, <code>namefirst</code>, <code>namelast</code> and <code>schoolid</code> of all people who were successfully inducted into the Hall of Fame — whether or not they played in college. Return people in _descending_ order of <code>playerid</code>. Break ties on <code>playerid</code> by <code>schoolid</code> (ascending). (Note: <code>schoolid</code> should be <code>NULL</code> if they did not play in college.)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> A.playerid, A.namefirst, A.namelast, B.schoolID<br><span class="hljs-keyword">FROM</span> q2i <span class="hljs-keyword">AS</span> A<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> collegeplaying <span class="hljs-keyword">AS</span> B <span class="hljs-keyword">ON</span> A.playerid <span class="hljs-operator">=</span> B.playerID <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> A.playerid <span class="hljs-keyword">DESC</span>,B.schoolID <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure><p>NOTE:<strong>LEFT JOIN (or LEFT OUTER JOIN):</strong> Retrieves all rows from the left table (the table specified before <code>LEFT JOIN</code>), and the matched rows from the right table. If there is no match in the right table, the result will contain NULL values for columns from the right table.</p><h3 id="Task-3-SaberMetrics"><a href="#Task-3-SaberMetrics" class="headerlink" title="Task 3: SaberMetrics"></a>Task 3: <a href="https://en.wikipedia.org/wiki/Sabermetrics"><strong>SaberMetrics</strong></a></h3><p><strong>i.</strong> Find the <code>playerid</code>, <code>namefirst</code>, <code>namelast</code>, <code>yearid</code> and single-year <code>slg</code> (Slugging Percentage) of the players with the 10 best annual Slugging Percentage recorded over all time. A player can appear multiple times in the output. For example, if Babe Ruth’s <code>slg</code> in 2000 and 2001 both landed in the top 10 best annual Slugging Percentage of all time, then we should include Babe Ruth twice in the output. For statistical significance, only include players with more than 50 at-bats in the season. Order the results by <code>slg</code> descending, and break ties by <code>yearid, playerid</code> (ascending).</p><ul><li>Baseball note: Slugging Percentage is not provided in the database; it is computed according to a <a href="https://en.wikipedia.org/wiki/Slugging\_percentage">simple formula</a> you can calculate from the data in the database.</li><li>SQL note: You should compute <code>slg</code> properly as a floating point number—-you’ll need to figure out how to convince SQL to do this!</li><li>Data set note: The online documentation <code>batting</code> mentions two columns <code>2B</code> and <code>3B</code>. On your local copy of the data set these have been renamed <code>H2B</code> and <code>H3B</code> respectively (columns starting with numbers are tedious to write queries on).</li><li>Data set note: The column <code>H</code> o f the <code>batting</code> table represents all hits = (# singles) + (# doubles) + (# triples) + (# home runs), not just (# singles) so you’ll need to account for some double-counting</li><li>If a player played on multiple teams during the same season (for example <code>anderma02</code> in 2006) treat their time on each team separately for this calculation</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> A.playerID,A.namefirst,A.namelast,B.yearID,B.SLG<br>  <span class="hljs-keyword">FROM</span>  people <span class="hljs-keyword">AS</span> A<br>  <span class="hljs-keyword">JOIN</span><br>    (<br>        <span class="hljs-keyword">SELECT</span> playerID,yearID,<br>        ROUND(((&quot;H&quot; <span class="hljs-operator">-</span> &quot;H2B&quot; <span class="hljs-operator">-</span> &quot;H3B&quot; <span class="hljs-operator">-</span> &quot;HR&quot;) <span class="hljs-operator">/</span> <span class="hljs-number">1.0</span> <span class="hljs-operator">+</span> &quot;H2B&quot; <span class="hljs-operator">/</span> <span class="hljs-number">1.0</span> <span class="hljs-operator">*</span> <span class="hljs-number">2</span> <span class="hljs-operator">+</span> &quot;H3B&quot; <span class="hljs-operator">/</span> <span class="hljs-number">1.0</span> <span class="hljs-operator">*</span> <span class="hljs-number">3</span> <span class="hljs-operator">+</span> &quot;HR&quot; <span class="hljs-operator">/</span> <span class="hljs-number">1.0</span> <span class="hljs-operator">*</span> <span class="hljs-number">4</span>) <span class="hljs-operator">/</span> <span class="hljs-built_in">NULLIF</span>(&quot;AB&quot;, <span class="hljs-number">0</span>),<span class="hljs-number">4</span>) <span class="hljs-keyword">AS</span> SLG<br>        <span class="hljs-keyword">FROM</span>  batting<br>        <span class="hljs-keyword">WHERE</span> AB <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span><br>        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> SLG <span class="hljs-keyword">DESC</span>,yearID <span class="hljs-keyword">ASC</span>,playerID <span class="hljs-keyword">ASC</span><br>        LIMIT <span class="hljs-number">10</span><br>    ) <span class="hljs-keyword">AS</span> B<br><span class="hljs-keyword">ON</span><br>    A.playerID <span class="hljs-operator">=</span> B.playerID;<br></code></pre></td></tr></table></figure><p><strong>ii.</strong> Following the results from Part i, find the <code>playerid</code>, <code>namefirst</code>, <code>namelast</code> and <code>lslg</code> (Lifetime Slugging Percentage) for the players with the top 10 Lifetime Slugging Percentage. Lifetime Slugging Percentage (LSLG) uses the same formula as Slugging Percentage (SLG), but it uses the number of singles, doubles, triples, home runs, and at bats each player has over their entire career, rather than just over a single season.</p><p>Note that the database only gives batting information broken down by year; you will need to convert to total information across all time (from the earliest date recorded up to the last date recorded) to compute <code>lslg</code>. Order the results by <code>lslg</code> (descending) and break ties by <code>playerid</code> (ascending)</p><ul><li>Note: Make sure that you only include players with more than 50 at-bats across their lifetime.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> A.playerID,A.namefirst,A.namelast,<br>  ROUND(((B.SH <span class="hljs-operator">-</span> B.SH2B <span class="hljs-operator">-</span> B.SH3B <span class="hljs-operator">-</span> B.SHR) <span class="hljs-operator">+</span> B.SH2B <span class="hljs-operator">*</span> <span class="hljs-number">2</span> <span class="hljs-operator">+</span> B.SH3B<span class="hljs-operator">*</span><span class="hljs-number">3</span> <span class="hljs-operator">+</span> B.SHR <span class="hljs-operator">*</span> <span class="hljs-number">4</span>) <span class="hljs-operator">/</span> <span class="hljs-built_in">NULLIF</span>(B.SAB, <span class="hljs-number">0</span>),<span class="hljs-number">4</span>) <span class="hljs-keyword">AS</span> LSLG <br>  <span class="hljs-keyword">FROM</span> people <span class="hljs-keyword">AS</span> A<br>  <span class="hljs-keyword">JOIN</span><br>  (<span class="hljs-keyword">SELECT</span> playerID, <span class="hljs-built_in">CAST</span>(<span class="hljs-built_in">sum</span>(AB) <span class="hljs-keyword">AS</span> <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">AS</span> SAB,<span class="hljs-built_in">CAST</span>(<span class="hljs-built_in">sum</span>(H) <span class="hljs-keyword">AS</span> <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">AS</span> SH,<span class="hljs-built_in">CAST</span>(<span class="hljs-built_in">sum</span>(H2B) <span class="hljs-keyword">AS</span> <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">AS</span> SH2B,<br>  <span class="hljs-built_in">CAST</span>(<span class="hljs-built_in">sum</span>(H3B) <span class="hljs-keyword">AS</span> <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">AS</span> SH3B,<span class="hljs-built_in">CAST</span>(<span class="hljs-built_in">sum</span>(HR) <span class="hljs-keyword">AS</span> <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">AS</span> SHR<br>  <span class="hljs-keyword">FROM</span> batting <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> playerID<br>  <span class="hljs-keyword">HAVING</span> SAB <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span>) <span class="hljs-keyword">AS</span> B <br>  <span class="hljs-keyword">ON</span> A.playerID <span class="hljs-operator">=</span> B.playerID<br>  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> LSLG <span class="hljs-keyword">DESC</span>,A.playerID <span class="hljs-keyword">ASC</span><br>  LIMIT <span class="hljs-number">10</span><br>;<br></code></pre></td></tr></table></figure><p><strong>iii.</strong> Find the <code>namefirst</code>, <code>namelast</code> and Lifetime Slugging Percentage (<code>lslg</code>) of batters whose lifetime slugging percentage is higher than that of San Francisco favorite Willie Mays.</p><p>You may include Willie Mays’ <code>playerid</code> in your query (<code>mayswi01</code>), but you _may not_ include his slugging percentage — you should calculate that as part of the query. (Test your query by replacing <code>mayswi01</code> with the playerid of another player — it should work for that player as well! We may do the same in the autograder.)</p><ul><li>Note: Make sure that you still only include players with more than 50 at-bats across their lifetime.</li></ul><p>_Just for fun_: For those of you who are baseball buffs, variants of the above queries can be used to find other more detailed SaberMetrics, like <a href="https://en.wikipedia.org/wiki/Runs\_created">Runs Created</a> or <a href="https://en.wikipedia.org/wiki/Value\_over\_replacement\_player">Value Over Replacement Player</a>. Wikipedia has a nice page on <a href="https://en.wikipedia.org/wiki/Baseball\_statistics">baseball statistics</a>; most of these can be computed fairly directly in SQL.</p><p>_Also just for fun_: SF Giants VP of Baseball Operations, <a href="https://www.mlb.com/giants/team/front-office/yeshayah-goldfarb">Yeshayah Goldfarb</a>, suggested the following:</p><blockquote><p>Using the Lahman database as your guide, make an argument for when MLBs “Steroid Era” started and ended. There are a number of different ways to explore this question using the data.</p></blockquote><p>(Please do not include your “just for fun” answers in your solution file! They will break the autograder.)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql">  <span class="hljs-keyword">SELECT</span> A.namefirst,A.namelast,<br>  ROUND(((B.SH <span class="hljs-operator">-</span> B.SH2B <span class="hljs-operator">-</span> B.SH3B <span class="hljs-operator">-</span> B.SHR) <span class="hljs-operator">+</span> B.SH2B <span class="hljs-operator">*</span> <span class="hljs-number">2</span> <span class="hljs-operator">+</span> B.SH3B<span class="hljs-operator">*</span><span class="hljs-number">3</span> <span class="hljs-operator">+</span> B.SHR <span class="hljs-operator">*</span> <span class="hljs-number">4</span>) <span class="hljs-operator">/</span> <span class="hljs-built_in">NULLIF</span>(B.SAB, <span class="hljs-number">0</span>),<span class="hljs-number">4</span>) <span class="hljs-keyword">AS</span> LSLG <br>  <span class="hljs-keyword">FROM</span> people <span class="hljs-keyword">AS</span> A<br>  <span class="hljs-keyword">JOIN</span><br>  (<span class="hljs-keyword">SELECT</span> playerID, <span class="hljs-built_in">CAST</span>(<span class="hljs-built_in">sum</span>(AB) <span class="hljs-keyword">AS</span> <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">AS</span> SAB,<span class="hljs-built_in">CAST</span>(<span class="hljs-built_in">sum</span>(H) <span class="hljs-keyword">AS</span> <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">AS</span> SH,<span class="hljs-built_in">CAST</span>(<span class="hljs-built_in">sum</span>(H2B) <span class="hljs-keyword">AS</span> <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">AS</span> SH2B,<br>  <span class="hljs-built_in">CAST</span>(<span class="hljs-built_in">sum</span>(H3B) <span class="hljs-keyword">AS</span> <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">AS</span> SH3B,<span class="hljs-built_in">CAST</span>(<span class="hljs-built_in">sum</span>(HR) <span class="hljs-keyword">AS</span> <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">AS</span> SHR<br>  <span class="hljs-keyword">FROM</span> batting <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> playerID<br>  <span class="hljs-keyword">HAVING</span> SAB <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span>) <span class="hljs-keyword">AS</span> B <br>  <span class="hljs-keyword">ON</span> A.playerID <span class="hljs-operator">=</span> B.playerID<br>  <span class="hljs-keyword">WHERE</span> LSLG <span class="hljs-operator">&gt;</span> <br>  #先算出mayswi01的lslg是多少，让LSLG大于这个数的数据展示出来<br>  (<span class="hljs-keyword">SELECT</span><br>  ROUND(((B.SH <span class="hljs-operator">-</span> B.SH2B <span class="hljs-operator">-</span> B.SH3B <span class="hljs-operator">-</span> B.SHR) <span class="hljs-operator">+</span> B.SH2B <span class="hljs-operator">*</span> <span class="hljs-number">2</span> <span class="hljs-operator">+</span> B.SH3B<span class="hljs-operator">*</span><span class="hljs-number">3</span> <span class="hljs-operator">+</span> B.SHR <span class="hljs-operator">*</span> <span class="hljs-number">4</span>) <span class="hljs-operator">/</span> <span class="hljs-built_in">NULLIF</span>(B.SAB, <span class="hljs-number">0</span>),<span class="hljs-number">4</span>) <span class="hljs-keyword">AS</span> LSLG <br>  <span class="hljs-keyword">FROM</span> <br>  (<span class="hljs-keyword">SELECT</span> playerID, <span class="hljs-built_in">CAST</span>(<span class="hljs-built_in">sum</span>(AB) <span class="hljs-keyword">AS</span> <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">AS</span> SAB,<span class="hljs-built_in">CAST</span>(<span class="hljs-built_in">sum</span>(H) <span class="hljs-keyword">AS</span> <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">AS</span> SH,<span class="hljs-built_in">CAST</span>(<span class="hljs-built_in">sum</span>(H2B) <span class="hljs-keyword">AS</span> <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">AS</span> SH2B,<br>  <span class="hljs-built_in">CAST</span>(<span class="hljs-built_in">sum</span>(H3B) <span class="hljs-keyword">AS</span> <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">AS</span> SH3B,<span class="hljs-built_in">CAST</span>(<span class="hljs-built_in">sum</span>(HR) <span class="hljs-keyword">AS</span> <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">AS</span> SHR<br>  <span class="hljs-keyword">FROM</span> batting <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> playerID<br>  <span class="hljs-keyword">HAVING</span> SAB <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span>) <span class="hljs-keyword">AS</span> B <br>  <span class="hljs-keyword">WHERE</span> B.playerID <span class="hljs-operator">=</span> &quot;mayswi01&quot;)<br>  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> A.namefirst;<br>;<br></code></pre></td></tr></table></figure><h3 id="Task-4-Salaries"><a href="#Task-4-Salaries" class="headerlink" title="Task 4: Salaries"></a>Task 4: <strong>Salaries</strong></h3><p><strong>i.</strong> Find the <code>yearid</code>, min, max and average of all player salaries for each year recorded, ordered by <code>yearid</code> in _ascending_ order.</p><p><strong>ii.</strong> For salaries in 2016, compute a <a href="https://en.wikipedia.org/wiki/Histogram">histogram</a>. Divide the salary range into 10 equal bins from min to max, with <code>binid</code>s 0 through 9, and count the salaries in each bin. Return the <code>binid</code>, <code>low</code> and <code>high</code> boundaries for each bin, as well as the number of salaries in each bin, with results sorted from smallest bin to largest.</p><ul><li>Note: <code>binid</code> 0 corresponds to the lowest salaries, and <code>binid</code> 9 corresponds to the highest. The ranges are left-inclusive (i.e. <code>[low, high)</code>) — so the <code>high</code> value is excluded. For example, if bin 2 has a <code>high</code> value of 100000, salaries of 100000 belong in bin 3, and bin 3 should have a <code>low</code> value of 100000.</li><li>Note: The <code>high</code> value for bin 9 may be inclusive).</li><li>Note: The test for this question is broken into two parts. Use <code>python3 test.py -q 4ii_bins_0_to_8</code> and <code>python3 test.py -q 4ii_bin_9</code> to run the tests</li><li>Hidden testing advice: we will be testing the case where a bin has zero player salaries in it. The correct behavior in this case is to display the correct <code>binid</code>, <code>low</code> and <code>high</code> with a <code>count</code> of zero, NOT just excluding the bin altogether.</li></ul><p>Some useful information:</p><ul><li>In the lahman.db, you may find it helpful to use the provided helper table <code>binids</code>, which contains all the possible <code>binid</code>s. Get a feel of what the data looks like by running <code>SELECT * FROM binids;</code> in a sqlite terminal. We’ll only be testing with these possible binids (there aren’t any hidden tests using say, 100 bins) so using the hardcoded table is fine</li><li>If you want to take the <a href="https://en.wikipedia.org/wiki/Floor\_and\_ceiling\_functions">floor </a>of a positive float value you can do <code>CAST (some_value AS INT)</code></li></ul><p><strong>iii.</strong> Now let’s compute the Year-over-Year change in min, max and average player salary. For each year with recorded salaries after the first, return the <code>yearid</code>, <code>mindiff</code>, <code>maxdiff</code>, and <code>avgdiff</code> with respect to the previous year. Order the output by <code>yearid</code> in _ascending_ order. (You should omit the very first year of recorded salaries from the result.)</p><p><strong>iv.</strong> In 2001, the max salary went up by over $6 million. Write a query to find the players that had the max salary in 2000 and 2001. Return the <code>playerid</code>, <code>namefirst</code>, <code>namelast</code>, <code>salary</code> and <code>yearid</code> for those two years. If multiple players tied for the max salary in a year, return all of them.</p><ul><li>Note on notation: you are computing a relational variant of the <a href="https://en.wikipedia.org/wiki/Arg\_max">argmax</a> for each of those two years.</li></ul><p><strong>v.</strong> Each team has at least 1 All Star and may have multiple. For each team in the year 2016, give the <code>teamid</code> and <code>diffAvg</code> (the difference between the team’s highest paid all-star’s salary and the team’s lowest paid all-star’s salary).</p><ul><li>Note: Due to some discrepancies in the database, please draw your team names from the All-Star table (so use <code>allstarfull.teamid</code> in the SELECT statement for this).</li></ul><h1 id="Disk-based-data-structure"><a href="#Disk-based-data-structure" class="headerlink" title="Disk-based data structure"></a>Disk-based data structure</h1><p>How to store date use an index</p><p>Index is a data structure that enables fast <strong>lookup</strong> and <strong>modification</strong> of <strong>data entries</strong> by <strong>search key</strong></p><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h2><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><ul><li>The number <code>d</code> is the order of a B+ tree. Each node (with the exception of the root node) must have <code>d</code> ≤ x ≤ <code>2d</code> entries assuming no deletes happen (it’s possible for leaf nodes to end up with &lt; d entries if you delete data). The entries within each node must be <strong>sorted</strong>.</li><li>In between each entry of an inner node, there is a pointer to a child node. Since there are at most <code>2d</code> entries in a node, inner nodes may have at most <code>2d+1</code> child pointers. This is also called the tree’s fanout.</li><li>The keys in the children to the left of an entry must be less than the entry while the keys in the children to the right must be greater than or equal to the entry.</li><li>All leaves are at the same depth and have between <code>d</code> and <code>2d</code> entries (i.e., at least half full)</li></ul><h3 id="how-to-insert-in-a-B-Tree"><a href="#how-to-insert-in-a-B-Tree" class="headerlink" title="how to insert in a B+Tree"></a>how to insert in a B+Tree</h3><p><img src="https://raw.githubusercontent.com/yanzhang404/Image/main/%E6%88%AA%E5%B1%8F2023-12-08%2016.43.21.png" alt="截屏2023-12-08 16.43.21"></p><p>To insert an entry into the B+ tree, follow this procedure:</p><ol><li>Find the leaf node <code>L</code> in which you will insert your value. You can do this by traversing down the tree. Add the key and the record to the leaf node in order.</li><li>If <code>L</code> overflows (<code>L</code> has more than <code>2d</code> entries)<ol><li>Split into <code>L_1</code> and <code>L_2</code>. Keep <code>d</code> entries in <code>L_1</code> (this means <code>d+1</code> entries will go in <code>L_2</code>).</li><li>If $L$ was a leaf node, <strong>COPY</strong> $L_2$’s first entry into the parent. If $L$ was not a leaf node, <strong>MOVE</strong> $L_2$’s first entry into the parent.</li><li>Adjust pointers.</li></ol></li></ol><p>Bulk loading a B+ tree</p><p><img src="https://raw.githubusercontent.com/yanzhang404/Image/main/%E6%88%AA%E5%B1%8F2023-12-08%2016.44.25.png" alt="截屏2023-12-08 16.44.25"></p><p><img src="https://raw.githubusercontent.com/yanzhang404/Image/main/%E6%88%AA%E5%B1%8F2023-12-08%2016.45.31.png" alt="截屏2023-12-08 16.45.31"></p><h3 id="Counting-IO’s"><a href="#Counting-IO’s" class="headerlink" title="Counting IO’s"></a>Counting IO’s</h3><p>Here’s the general procedure. It’s a good thing to write on your cheat sheet:</p><ol><li>Read the appropriate root-to-leaf path.</li><li>Read the appropriate data page(s). If we need to read multiple pages, we will allot a read IO for each page. In addition, we account for clustering for Alt. 2 or 3 (see below.)</li><li>Write data page, if you want to modify it. Again, if we want to do a write that spans multiple data pages, we will need to allot a write IO for each page.</li><li>Update index page(s).</li></ol><h1 id="Project2"><a href="#Project2" class="headerlink" title="Project2"></a>Project2</h1><h2 id="Some-important-class"><a href="#Some-important-class" class="headerlink" title="Some important class"></a>Some important class</h2><p><strong>Buffer &amp;&amp; ByteBuffer</strong>:</p><blockquote><p>Buffers are used to store and sequences of bytes, for example when we want to serialize information into a byte sequence that can be stored on disk and deserialize the sequence back into a Java object. Put methods will return the buffer itself allowing you to chain together calls to put. For example, calling</p></blockquote><p>We wrapper around java.nio.ByteBuffer to implement our Buffer interface.</p><p><strong>BufferFrame &amp;&amp; Buffer Manager</strong></p><p><strong>Page &amp;&amp; PageDirectory</strong></p><p><strong>BPlusNode</strong>:</p><p>There are InnerNode and LeafNode extend BPlusNode.</p><p>Some  methods:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Optional&lt;Pair&lt;DataBox, Long&gt;&gt; <span class="hljs-title function_">put</span><span class="hljs-params">(DataBox key, RecordId rid)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>n.put(k, r) inserts the pair (k, r) into the subtree rooted by n.</p><p>There are two cases to consider:<br>Case 1: If inserting the pair (k, r) does NOT cause n to overflow, then Optional.empty() is returned.<br>Case 2: If inserting the pair (k, r) does cause the node n to overflow,then n is split into a left and right node (described more below) and a pair (split_key, right_node_page_num) is returned where right_node_page_num is the page number of the newly created right node, and the value of split_key depends on whether n is an inner node or a leaf node (described more below).</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Optional&lt;Pair&lt;DataBox, Long&gt;&gt; <span class="hljs-title function_">bulkLoad</span><span class="hljs-params">(Iterator&lt;Pair&lt;DataBox, RecordId&gt;&gt; data,</span><br><span class="hljs-params">        <span class="hljs-type">float</span> fillFactor)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>n.bulkLoad(data, fillFactor) bulk loads pairs of (k, r) from data into the tree with the given fill factor.</p></blockquote><p><strong>BPlusTreeMetadata</strong></p><h2 id="Your-Tasks-1"><a href="#Your-Tasks-1" class="headerlink" title="Your Tasks"></a>Your Tasks</h2><h3 id="Task-1-LeafNode-fromBytes"><a href="#Task-1-LeafNode-fromBytes" class="headerlink" title="Task 1: LeafNode::fromBytes"></a>Task 1: LeafNode::fromBytes</h3><p>You should first implement the <code>fromBytes</code> in <code>LeafNode</code>. This method reads a <code>LeafNode</code> from a page. For information on how a leaf node is serialized, see <code>LeafNode::toBytes</code>. For an example on how to read a node from disk, see <code>InnerNode::fromBytes</code>. Your code should be similar to the inner node version but should account for the differences between how inner nodes and leaf nodes are serialized. You may find the documentation in <a href="https://github.com/berkeley-cs186/fa23-rookiedb/blob/master/src/main/java/edu/berkeley/cs186/database/common/ByteBuffer.java#L5"><code>ByteBuffer.java</code></a> helpful.</p><p>Once you have implemented <code>fromBytes</code> you should be passing <code>TestLeafNode::testToAndFromBytes</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LeafNode <span class="hljs-title function_">fromBytes</span><span class="hljs-params">(BPlusTreeMetadata metadata, BufferManager bufferManager,</span><br><span class="hljs-params">                                    LockContext treeContext, <span class="hljs-type">long</span> pageNum)</span> &#123;<br>       <span class="hljs-comment">// TODO(proj2): implement</span><br>       <span class="hljs-comment">// Note: LeafNode has two constructors. To implement fromBytes be sure to</span><br>       <span class="hljs-comment">// use the constructor that reuses an existing page instead of fetching a</span><br>       <span class="hljs-comment">// brand new one.</span><br>       <span class="hljs-type">Page</span> <span class="hljs-variable">page</span> <span class="hljs-operator">=</span> bufferManager.fetchPage(treeContext, pageNum);<br>       <span class="hljs-type">Buffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> page.getBuffer();<br><br>       <span class="hljs-type">byte</span> <span class="hljs-variable">nodeType</span> <span class="hljs-operator">=</span> buf.get();<br>       <span class="hljs-keyword">assert</span> (nodeType == (<span class="hljs-type">byte</span>) <span class="hljs-number">1</span>);<br><br>       <span class="hljs-type">long</span> <span class="hljs-variable">rightSibling_t</span> <span class="hljs-operator">=</span> buf.getLong();<br>  <span class="hljs-comment">//要判断一下rightSibling是不是-1</span><br>  <span class="hljs-keyword">if</span>(rightSibling_t.equals(-<span class="hljs-number">1L</span>))&#123;<br>           rightSibling_t = <span class="hljs-literal">null</span>;<br>       &#125;<br>       <span class="hljs-comment">//这边出现bug，没有用Optional.ofNullable</span><br>   <span class="hljs-comment">//Optional&lt;Long&gt; rightSibling = Optional.of(rightSibling_t);</span><br>       Optional&lt;Long&gt; rightSibling = Optional.ofNullable(rightSibling_t);<br>       <span class="hljs-type">int</span> <span class="hljs-variable">keysSize</span> <span class="hljs-operator">=</span> buf.getInt();<br>       List&lt;DataBox&gt; keys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>       List&lt;RecordId&gt; rids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; keysSize; i++)&#123;<br>           keys.add(DataBox.fromBytes(buf,metadata.getKeySchema()));<br>           rids.add(RecordId.fromBytes(buf));<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeafNode</span>(metadata,bufferManager,page,keys,rids,rightSibling,treeContext);<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="Task-2-get-getLeftmostLeaf-put-remove"><a href="#Task-2-get-getLeftmostLeaf-put-remove" class="headerlink" title="Task 2: get, getLeftmostLeaf, put, remove"></a>Task 2: get, getLeftmostLeaf, put, remove</h3><p>After implementing <code>fromBytes</code>, you will need to implement the following methods in <code>LeafNode</code>, <code>InnerNode</code>, and <code>BPlusTree</code>:</p><ul><li><code>get</code></li><li><code>getLeftmostLeaf</code> (<code>LeafNode</code> and <code>InnerNode</code> only)</li><li><code>put</code></li><li><code>remove</code></li></ul><p>For more information on what these methods should do refer to the comments in <code>BPlusTree</code> and <code>BPlusNode</code>.</p><p>Each of these methods, although split into three different classes, can be viewed as one recursive action each - the <code>BPlusTree</code> method starts the call, the <code>InnerNode</code> method is the recursive case, and the <code>LeafNode</code> method is the base case. It’s suggested that you work on one method at a time (over all three classes).</p><p>We’ve provided a <code>sync()</code> method in <code>LeafNode</code> and <code>InnerNode</code>. The purpose of <code>sync()</code> is to ensure that representation of a node in our buffers is up-to-date with the representation of the node in program memory. <strong>Do not forget to call <code>sync()</code> when implementing the two mutating methods</strong> (<code>put</code> and <code>remove</code>); it’s easy to forget.</p><p>Code:</p><p><code>get</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//LeafNode: </span><br>   <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> LeafNode <span class="hljs-title function_">get</span><span class="hljs-params">(DataBox key)</span> &#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-comment">// TODO(proj2): implement</span><br>    &#125;<br>    <br><span class="hljs-comment">//InnerNode:</span><br> <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> LeafNode <span class="hljs-title function_">get</span><span class="hljs-params">(DataBox key)</span> &#123;<br>        <span class="hljs-keyword">if</span>(!keys.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">childIndex</span> <span class="hljs-operator">=</span> numLessThanEqual(key,keys);<br>            <span class="hljs-keyword">return</span> getChild(childIndex).get(key);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><span class="hljs-comment">//BPlusTree:</span><br>   <span class="hljs-keyword">public</span> Optional&lt;RecordId&gt; <span class="hljs-title function_">get</span><span class="hljs-params">(DataBox key)</span> &#123;<br>        typecheck(key);<br>        <span class="hljs-comment">// TODO(proj4_integration): Update the following line</span><br>        LockUtil.ensureSufficientLockHeld(lockContext, LockType.NL);<br><br><br>        <span class="hljs-comment">// TODO(proj2): implement</span><br>        <span class="hljs-keyword">return</span> root.get(key).getKey(key);<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>getLeftmostLeaf</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//LeafNode</span><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> LeafNode <span class="hljs-title function_">getLeftmostLeaf</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// TODO(proj2): implement</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><span class="hljs-comment">//InnerNode:</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> LeafNode <span class="hljs-title function_">getLeftmostLeaf</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">assert</span>(children.size() &gt; <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// TODO(proj2): implement</span><br>        <span class="hljs-keyword">return</span> getChild(<span class="hljs-number">0</span>).getLeftmostLeaf();<br><br>    &#125;<br></code></pre></td></tr></table></figure><p><code>put</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//leafNode   </span><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Optional&lt;Pair&lt;DataBox, Long&gt;&gt; <span class="hljs-title function_">put</span><span class="hljs-params">(DataBox key, RecordId rid)</span> &#123;<br>        <span class="hljs-comment">// TODO(proj2): implement</span><br>        <span class="hljs-keyword">if</span>(keys.contains(key))&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BPlusTreeException</span>(<span class="hljs-string">&quot;duplicate keys!&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> metadata.getOrder();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">insertIndex</span> <span class="hljs-operator">=</span> InnerNode.numLessThanEqual(key,keys);<br>        keys.add(insertIndex,key);<br>        rids.add(insertIndex,rid);<br>        <span class="hljs-keyword">if</span>(keys.size()&lt;=<span class="hljs-number">2</span>*d)&#123;<br>            sync();<br>            <span class="hljs-keyword">return</span> Optional.empty();<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            List&lt;DataBox&gt; dataBoxes = keys.subList(d,keys.size());<br>            List&lt;RecordId&gt; recordIds = rids.subList(d,keys.size());<br>            keys = keys.subList(<span class="hljs-number">0</span>,d);<br>            rids = rids.subList(<span class="hljs-number">0</span>,d);<br><br>            <span class="hljs-type">LeafNode</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeafNode</span>(metadata,bufferManager,dataBoxes,recordIds,rightSibling,treeContext);<br>            <span class="hljs-built_in">this</span>.rightSibling = Optional.of(rs.getPage().getPageNum());<br>            sync();<br>            <span class="hljs-keyword">return</span> Optional.of(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(dataBoxes.get(<span class="hljs-number">0</span>),rs.getPage().getPageNum()));<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//InnerNode</span><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Optional&lt;Pair&lt;DataBox, Long&gt;&gt; <span class="hljs-title function_">put</span><span class="hljs-params">(DataBox key, RecordId rid)</span> &#123;<br>        <span class="hljs-comment">// TODO(proj2): implement</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> numLessThanEqual(key,keys);<br>        <span class="hljs-type">BPlusNode</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> getChild(index);<br>        Optional&lt;Pair&lt;DataBox,Long&gt;&gt; backNode = child.put(key,rid);<br>        <span class="hljs-keyword">if</span>(!backNode.isPresent())&#123;<br>            <span class="hljs-keyword">return</span> Optional.empty();<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            Pair&lt;DataBox,Long&gt; pair = backNode.get();<br>            <span class="hljs-keyword">return</span> insert(pair.getFirst(),pair.getSecond());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Optional&lt;Pair&lt;DataBox,Long&gt;&gt; <span class="hljs-title function_">insert</span><span class="hljs-params">(DataBox key, Long pageNum)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> numLessThanEqual(key,keys);<br>        keys.add(index,key);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> metadata.getOrder();<br>        <span class="hljs-keyword">if</span>(keys.size() &lt;= <span class="hljs-number">2</span>*d)&#123;<br>            sync();<br>            <span class="hljs-keyword">return</span> Optional.empty();<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">DataBox</span> <span class="hljs-variable">dataBox</span> <span class="hljs-operator">=</span> keys.get(d);<br>            List&lt;DataBox&gt; dataBoxes = keys.subList(d+<span class="hljs-number">1</span>, keys.size());<br>            List&lt;Long&gt; longs = children.subList(d+<span class="hljs-number">1</span>,children.size());<br>            keys = keys.subList(<span class="hljs-number">0</span>,d);<br>            children = children.subList(<span class="hljs-number">0</span>,d+<span class="hljs-number">1</span>);<br>            sync();<br>            <span class="hljs-type">InnerNode</span> <span class="hljs-variable">innerNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerNode</span>(metadata,bufferManager,dataBoxes,longs,treeContext);<br>            <span class="hljs-keyword">return</span> Optional.of(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(dataBox,innerNode.getPage().getPageNum()));<br><br>        &#125;<br>    &#125;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//BPlusTree</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(DataBox key, RecordId rid)</span> &#123;<br>        typecheck(key);<br>        <span class="hljs-comment">// TODO(proj4_integration): Update the following line</span><br>        LockUtil.ensureSufficientLockHeld(lockContext, LockType.NL);<br><br>        <span class="hljs-comment">// TODO(proj2): implement</span><br>        Optional&lt;Pair&lt;DataBox,Long&gt;&gt; back = root.put(key, rid);<br>        back.ifPresent(dataBoxLongPair -&gt;splitRoot(dataBoxLongPair.getFirst(), dataBoxLongPair.getSecond()));<br><br>        <span class="hljs-comment">// Note: You should NOT update the root variable directly.</span><br>        <span class="hljs-comment">// Use the provided updateRoot() helper method to change</span><br>        <span class="hljs-comment">// the tree&#x27;s root if the old root splits.</span><br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">splitRoot</span><span class="hljs-params">(DataBox key, Long child)</span>&#123;<br>        List&lt;DataBox&gt; nKeys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        nKeys.add(key);<br>        List&lt;Long&gt; nChildren = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        nChildren.add(child);<br>        <span class="hljs-type">InnerNode</span> <span class="hljs-variable">newRoot</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerNode</span>(metadata,bufferManager,nKeys,nChildren,lockContext);<br>        updateRoot(newRoot);<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>remove</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//leafNode</span><br><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(DataBox key)</span> &#123;<br>        <span class="hljs-comment">// TODO(proj2): implement</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> keys.indexOf(key);<br>        <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            keys.remove(index);<br>            rids.remove(index);<br>          <span class="hljs-comment">//sync() is important</span><br>            sync();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br><br><span class="hljs-comment">//InnerNode</span><br>   <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(DataBox key)</span> &#123;<br>        <span class="hljs-comment">// TODO(proj2): implement</span><br>        <span class="hljs-type">LeafNode</span> <span class="hljs-variable">targetNode</span> <span class="hljs-operator">=</span> get(key);<br>        targetNode.remove(key);<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="Task-3-Scans"><a href="#Task-3-Scans" class="headerlink" title="Task 3: Scans"></a>Task 3: Scans</h3><p>You will need to implement the following methods in <code>BPlusTree</code>:</p><ul><li><code>scanAll</code></li><li><code>scanGreaterEqual</code></li></ul><p>In order to implement these, you will have to complete the <a href="https://github.com/berkeley-cs186/fa23-rookiedb/blob/master/src/main/java/edu/berkeley/cs186/database/index/BPlusTree.java#L422"><code>BPlusTreeIterator</code></a> inner class in <code>BPlusTree.java</code>to complete these two methods.</p><p>After completing this Task you should be passing <code>TestBPlusTree::testRandomPuts</code></p><p>Your implementation <strong>does not</strong> have to account for the tree being modified during a scan. For the time being you can think of this as there being a lock that prevents scanning and mutation from overlapping, and that the behavior of iterators created before a modification is undefined (you can handle any problems with these iterators however you like, or not at all).</p><p><strong>Iterator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BPlusTreeIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;RecordId&gt; &#123;<br>        <span class="hljs-comment">// TODO(proj2): Add whatever fields and constructors you want here.</span><br>        LeafNode currNode;<br>        Iterator&lt;RecordId&gt; currIter;<br><br>        BPlusTreeIterator(LeafNode node)&#123;<br>            <span class="hljs-built_in">this</span>.currNode = node;<br>            currIter = currNode.scanAll();<br>        &#125;<br><br>        BPlusTreeIterator(LeafNode node, DataBox key)&#123;<br>            <span class="hljs-built_in">this</span>.currNode = node;<br>            <span class="hljs-built_in">this</span>.currIter = currNode.scanGreaterEqual(key);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// TODO(proj2): implement</span><br>          <span class="hljs-comment">//如果当前的叶节点里还有next，返回true</span><br>            <span class="hljs-keyword">if</span>(currIter.hasNext())&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>          <span class="hljs-comment">//如果当前没有了，但是还有rightSibling，那也还是true</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                Optional&lt;LeafNode&gt; rightSibling = currNode.getRightSibling();<br>                <span class="hljs-keyword">if</span>(rightSibling.isPresent())&#123;<br>                    currNode = rightSibling.get();<br>                    currIter = currNode.scanAll();<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> RecordId <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// TODO(proj2): implement</span><br>            <span class="hljs-keyword">if</span>(currIter.hasNext())&#123;<br>                <span class="hljs-keyword">return</span> currIter.next();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>scanall</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Iterator&lt;RecordId&gt; <span class="hljs-title function_">scanAll</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO(proj4_integration): Update the following line</span><br>      LockUtil.ensureSufficientLockHeld(lockContext, LockType.NL);<br>      <span class="hljs-comment">// TODO(proj2): Return a BPlusTreeIterator.</span><br>  <span class="hljs-type">LeafNode</span> <span class="hljs-variable">leafNode</span> <span class="hljs-operator">=</span> root.getLeftmostLeaf();<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BPlusTreeIterator</span>(leafNode);<br>  &#125;<br><br></code></pre></td></tr></table></figure><p><strong>scanGreaterEqual</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Iterator&lt;RecordId&gt; <span class="hljs-title function_">scanGreaterEqual</span><span class="hljs-params">(DataBox key)</span> &#123;<br>      typecheck(key);<br>      <span class="hljs-comment">// TODO(proj4_integration): Update the following line</span><br>      LockUtil.ensureSufficientLockHeld(lockContext, LockType.NL);<br><br>      <span class="hljs-comment">// TODO(proj2): Return a BPlusTreeIterator.</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BPlusTreeIterator</span>(root.get(key),key);<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="Task-4-Bulk-Load"><a href="#Task-4-Bulk-Load" class="headerlink" title="Task 4: Bulk Load"></a>Task 4: Bulk Load</h3><p>Much like the methods from the Task 2 you’ll need to implement <code>bulkLoad</code> within all three of <code>LeafNode</code>, <code>InnerNode</code>, and <code>BPlusTree</code>. Since bulk loading is a mutating operation you will need to call <code>sync()</code>. Be sure to read the instructions in <a href="https://github.com/berkeley-cs186/fa23-rookiedb/blob/master/src/main/java/edu/berkeley/cs186/database/index/BPlusNode.java#L162"><code>BPluNode::bulkLoad</code></a> carefully to ensure you split your nodes properly. We’ve provided a visualization of bulk loading for an order 2 tree with fill factor 0.75 (<a href="https://docs.google.com/presentation/d/1\_ghdp60NV6XRHnutFAL20k2no6tr2PosXGokYtR8WwU/edit?usp=sharing">powerpoint slides here</a>):</p><p><strong>leafNode:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Optional&lt;Pair&lt;DataBox, Long&gt;&gt; <span class="hljs-title function_">bulkLoad</span><span class="hljs-params">(Iterator&lt;Pair&lt;DataBox, RecordId&gt;&gt; data,</span><br><span class="hljs-params">          <span class="hljs-type">float</span> fillFactor)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> metadata.getOrder();<br>      <span class="hljs-comment">// TODO(proj2): implement</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">maxNum</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)Math.ceil(fillFactor*<span class="hljs-number">2</span>*d);<br>      <span class="hljs-keyword">while</span>(keys.size() &lt; maxNum &amp;&amp; data.hasNext()) &#123;<br>          Pair&lt;DataBox, RecordId&gt; pair = data.next();<br>          <span class="hljs-type">DataBox</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> pair.getFirst();<br>          <span class="hljs-type">RecordId</span> <span class="hljs-variable">rid</span> <span class="hljs-operator">=</span> pair.getSecond();<br>        <span class="hljs-comment">//批量load直接add即可，put是找到插入到位置add，需要index</span><br>          keys.add(key);<br>          rids.add(rid);<br>      &#125;<br>      Optional&lt;Pair&lt;DataBox,Long&gt;&gt; ret = Optional.empty();<br>    <br>    <span class="hljs-comment">//如果超了在右边加1个</span><br>      <span class="hljs-keyword">if</span>(data.hasNext())&#123;<br>          List&lt;DataBox&gt; nKeys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>          List&lt;RecordId&gt; nRecords = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>          Pair&lt;DataBox,RecordId&gt; pair = data.next();<br>          <span class="hljs-type">DataBox</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> pair.getFirst();<br>          <span class="hljs-type">RecordId</span> <span class="hljs-variable">rid</span> <span class="hljs-operator">=</span> pair.getSecond();<br>          nKeys.add(key);<br>          nRecords.add(rid);<br>          <span class="hljs-type">LeafNode</span> <span class="hljs-variable">leafNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeafNode</span>(metadata,bufferManager,nKeys,nRecords,rightSibling,treeContext);<br>          rightSibling = Optional.of(leafNode.getPage().getPageNum());<br>          ret = Optional.of(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(pair.getFirst(),rightSibling.get()));<br>      &#125;<br>      sync();<br>      <span class="hljs-keyword">return</span> ret;<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>InnerNode：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> Optional&lt;Pair&lt;DataBox, Long&gt;&gt; <span class="hljs-title function_">bulkLoad</span><span class="hljs-params">(Iterator&lt;Pair&lt;DataBox, RecordId&gt;&gt; data,</span><br><span class="hljs-params">         <span class="hljs-type">float</span> fillFactor)</span> &#123;<br>     <span class="hljs-comment">// TODO(proj2): implement</span><br>     <span class="hljs-type">BPlusNode</span> <span class="hljs-variable">rightMostChild</span> <span class="hljs-operator">=</span> getChild(children.size() - <span class="hljs-number">1</span>);<br>     Optional&lt;Pair&lt;DataBox,Long&gt;&gt; backNode = rightMostChild.bulkLoad(data,fillFactor);<br>     <span class="hljs-keyword">if</span>(!backNode.isPresent())&#123;<br>         <span class="hljs-keyword">return</span> backNode;<br>     &#125;<span class="hljs-keyword">else</span>&#123;<br>         <span class="hljs-type">DataBox</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> backNode.get().getFirst();<br>         <span class="hljs-type">Long</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> backNode.get().getSecond();<br>         Optional&lt;Pair&lt;DataBox,Long&gt;&gt;    info = insert(k,child);<br>         <span class="hljs-keyword">if</span>(!info.isPresent())&#123;<br>             <span class="hljs-keyword">return</span> bulkLoad(data,fillFactor);<br>         &#125;<span class="hljs-keyword">else</span> &#123;<br>             <span class="hljs-keyword">return</span> info;<br>         &#125;<br>     &#125;<br> &#125;<br><br></code></pre></td></tr></table></figure><p>这里还有点疑惑</p><p>BplusTree：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bulkLoad</span><span class="hljs-params">(Iterator&lt;Pair&lt;DataBox, RecordId&gt;&gt; data, <span class="hljs-type">float</span> fillFactor)</span> &#123;<br>    <span class="hljs-comment">// TODO(proj4_integration): Update the following line</span><br>    LockUtil.ensureSufficientLockHeld(lockContext, LockType.NL);<br><br>    <span class="hljs-comment">// TODO(proj2): implement</span><br>    <span class="hljs-keyword">if</span>(scanAll().hasNext())&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BPlusTreeException</span>(<span class="hljs-string">&quot;must be called in an empty tree&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(data.hasNext())&#123;<br>        Optional&lt;Pair&lt;DataBox,Long&gt;&gt; backNode = root.bulkLoad(data,fillFactor);<br>        backNode.ifPresent(dataBoxLongPair -&gt; splitRoot(dataBoxLongPair.getFirst(),dataBoxLongPair.getSecond()));<br>    &#125;<br></code></pre></td></tr></table></figure><p>和put类似。</p><p><strong>All test pass.</strong></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day12</title>
    <link href="/2023/12/12/leetcode-day12/"/>
    <url>/2023/12/12/leetcode-day12/</url>
    
    <content type="html"><![CDATA[<h2 id="比较版本号-165"><a href="#比较版本号-165" class="headerlink" title="比较版本号(165)"></a>比较版本号(<a href="https://leetcode.cn/problems/compare-version-numbers/description/">165</a>)</h2><p>记录每个点之前的数，相当于比较一个数组的字典序。</p><p>可以使用stoi，直接忽略了前导零。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compareVersion</span><span class="hljs-params">(string v1, string v2)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; v1.<span class="hljs-built_in">size</span>() || j &lt; v2.<span class="hljs-built_in">size</span>();)&#123;<br>            <span class="hljs-type">int</span> a = i, b = j;<br>            <span class="hljs-keyword">while</span>(a &lt; v1.<span class="hljs-built_in">size</span>() &amp;&amp; v1[a] != <span class="hljs-string">&#x27;.&#x27;</span>) a++;<br>            <span class="hljs-keyword">while</span>(b &lt; v2.<span class="hljs-built_in">size</span>() &amp;&amp; v2[b] != <span class="hljs-string">&#x27;.&#x27;</span>) b++;<br>            <span class="hljs-type">int</span> x = a == i ? <span class="hljs-number">0</span> : <span class="hljs-built_in">stoi</span>(v1.<span class="hljs-built_in">substr</span>(i, a - i));<br>            <span class="hljs-type">int</span> y = b == j ? <span class="hljs-number">0</span> : <span class="hljs-built_in">stoi</span>(v2.<span class="hljs-built_in">substr</span>(j, b - j));<br>            <span class="hljs-keyword">if</span>( x &gt; y)  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>( x &lt; y)  <span class="hljs-keyword">return</span>  <span class="hljs-number">-1</span>;<br>            i = a + <span class="hljs-number">1</span>;<br>            j = b + <span class="hljs-number">1</span>;<br>         &#125;<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="缺失的第一个正数-41"><a href="#缺失的第一个正数-41" class="headerlink" title="缺失的第一个正数(41)"></a>缺失的第一个正数(<a href="https://leetcode.cn/problems/first-missing-positive/description/">41</a>)</h2><p>自己写了一个看起来比较丑的，居然也过了，但是比较耗时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                s.<span class="hljs-built_in">insert</span>(nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">size</span>())   <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e : s)&#123;<br>            temp.<span class="hljs-built_in">push_back</span>(e);<br>        &#125;<br>        <span class="hljs-comment">//cout&lt;&lt;temp[0]&lt;&lt;endl;</span><br>        <span class="hljs-keyword">if</span>(temp[<span class="hljs-number">0</span>]!= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; temp.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(temp[i] + <span class="hljs-number">1</span> != temp[i+<span class="hljs-number">1</span>])    <span class="hljs-keyword">return</span> temp[i] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(temp[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> temp.<span class="hljs-built_in">back</span>() + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>用了一个set来保存正数，如果set空说明没有正数直接输出1。</p><p>后来发现只要用一个count就行了，不需要写这么一大串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unorder_set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                s.<span class="hljs-built_in">insert</span>(nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(s.<span class="hljs-built_in">count</span>(res))res++;<br>        <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但这样空间并不是常数级别的，因此不符合题意的。</p><p>要想别的办法。</p><p>因为最后的答案只会出现在1-n+1内，所以我们只需要在原数组上进行修改即可，要让第0位为1，第1位为2，第n-1位为n，其他的不用管，最后第一个不满足上述条件的，就是答案。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; n &amp;&amp; nums[i] != nums[nums[i] - <span class="hljs-number">1</span>])&#123;<br>              <span class="hljs-comment">//因为这里nums[i]在1-n-1，所以数组里存在下标为nums[i] - 1的下标，让这个下标存nums[i]</span><br>                <span class="hljs-built_in">swap</span>(nums[i],nums[nums[i] - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != i + <span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="倒数第k个节点-LCR140"><a href="#倒数第k个节点-LCR140" class="headerlink" title="倒数第k个节点(LCR140)"></a>倒数第k个节点(<a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/description/">LCR140</a>)</h2><p>Easy</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">trainingPlan</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> cnt)</span> </span>&#123;<br>        ListNode *q = head;<br>        ListNode *p = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++)    q = q-&gt;next;<br>        <span class="hljs-keyword">while</span>(q != <span class="hljs-literal">nullptr</span>)&#123;<br>            p = p-&gt;next;<br>            q = q-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="子集-78"><a href="#子集-78" class="headerlink" title="子集(78)"></a>子集(<a href="https://leetcode.cn/problems/subsets/description/">78</a>)</h2><p>就是全排列的题目吧，用dfs对每个位置，选或者不选都行。</p><p>递归的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vis;<br>    <span class="hljs-type">int</span> n;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">t</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        vis = t;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>( u == n)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>                <span class="hljs-keyword">if</span>(vis[i] == <span class="hljs-number">1</span>)&#123;<br>                    temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                &#125; <br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        vis[u] = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>,nums);<br>        vis[u] = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>,nums);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>也可以用迭代来写，一个很巧妙的方法是，用一个长度为n的二进制数来表示，刚好可以表示2的n次方个子集，第i位为1就代表这个数选，否则为不选，比如n=3的数有，000，001，010，011，100，101，110，111共8种。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span>&lt;&lt;n; i++)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(i &gt;&gt; j &amp; <span class="hljs-number">1</span>)  temp.<span class="hljs-built_in">push_back</span>(nums[j]);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最小覆盖子串-76"><a href="#最小覆盖子串-76" class="headerlink" title="最小覆盖子串(76)"></a>最小覆盖子串(<a href="https://leetcode.cn/problems/minimum-window-substring/description/">76</a>)</h2><p>滑动窗口的题目，遍历每个位置作为终点的时候，找到包含所有t中字符的子串。保证end右移的时候start不会左移即可用滑动窗口。</p><p>依然是用哈希表存储每个字符，这里用两个哈希表。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hs, ht;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a : t) ht[a]++;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        string res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;end &lt; s.<span class="hljs-built_in">size</span>(); end++)&#123;<br>            hs[s[end]]++;<br>            <span class="hljs-keyword">if</span>(hs[s[end]] &lt;= ht[s[end]])    cnt++;<br>          <span class="hljs-comment">//如果加入之后发现开头的元素多了，那就把它删掉。</span><br>            <span class="hljs-keyword">while</span>(hs[s[start]] &gt; ht[s[start]])  hs[s[start++]]--;<br><br>            <span class="hljs-keyword">if</span>(cnt == t.<span class="hljs-built_in">size</span>())&#123;<br>              <span class="hljs-comment">//如果这个子串更短，那就更新答案</span><br>                <span class="hljs-keyword">if</span>(end - start + <span class="hljs-number">1</span> &lt; res.<span class="hljs-built_in">size</span>() || res.<span class="hljs-built_in">empty</span>()) <br>                    res = s.<span class="hljs-built_in">substr</span>(start,end- start + <span class="hljs-number">1</span>);<br>            &#125;;  <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day11</title>
    <link href="/2023/12/11/leetcode-day11/"/>
    <url>/2023/12/11/leetcode-day11/</url>
    
    <content type="html"><![CDATA[<h2 id="括号生成-22"><a href="#括号生成-22" class="headerlink" title="括号生成(22)"></a>括号生成(<a href="https://leetcode.cn/problems/generate-parentheses/description/">22</a>)</h2><p>如何判断一个只含小括号的序列是都匹配的括号序列。</p><p>1.任意前缀中，左括号数量大于右括号。</p><p>2.左右括号总数量相等。（本题均为n）</p><p>满足以上条件即合法，本题只需考虑第一个条件。</p><span id="more"></span><p>dfs的题目都是对于某个位置上可以填哪些东西，给这些东西一些限制，</p><p>比如全排列，每个位置只能填没有访问过的，八皇后，必须填满足条件的列等等。</p><p>本题则需要考虑，什么时候可以填左括号，什么时候可以填右括号。</p><p>只要有左括号就能填，右括号则需要少于左括号就能填。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(n,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> lc, <span class="hljs-type">int</span> rc, string path)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(lc == n &amp;&amp; rc == n)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(lc &lt; n)  <span class="hljs-built_in">dfs</span>(n,lc+<span class="hljs-number">1</span>,rc,path+<span class="hljs-string">&#x27;(&#x27;</span>);<br>            <span class="hljs-keyword">if</span>(rc &lt; n &amp;&amp; lc &gt; rc) <span class="hljs-built_in">dfs</span>(n, lc, rc + <span class="hljs-number">1</span>, path+<span class="hljs-string">&#x27;)&#x27;</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="两数相加-2"><a href="#两数相加-2" class="headerlink" title="两数相加(2)"></a>两数相加(<a href="https://leetcode.cn/problems/add-two-numbers/description/">2</a>)</h2><p>就是跟之前遇到的模拟竖式一样，每次要判断有没有进位。还是比较好想的。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode *p = dummy;<br>        <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 &amp;&amp; l2)&#123;<br>            <span class="hljs-type">int</span> a = l1-&gt;val;<br>            <span class="hljs-type">int</span> b = l2-&gt;val;<br>            <span class="hljs-type">int</span> s = (a + b + c) % <span class="hljs-number">10</span>;<br>            c = (a+b+c) / <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">auto</span> q = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(s);<br>            p-&gt;next = q;<br>            p = q;<br>            l1 = l1-&gt;next;<br>            l2 = l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(l1)&#123;<br>            <span class="hljs-type">int</span> a = l1-&gt;val;<br>            <span class="hljs-type">int</span> s = (a + c) %<span class="hljs-number">10</span>;<br>            c = (a + c) / <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">auto</span> q = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(s);<br>            p-&gt;next = q;<br>            p = q;<br>            l1 = l1-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(l2)&#123;<br>            <span class="hljs-type">int</span> a = l2-&gt;val;<br>            <span class="hljs-type">int</span> s = (a + c) %<span class="hljs-number">10</span>;<br>            c = (a + c) / <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">auto</span> q = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(s);<br>            p-&gt;next = q;<br>            p = q;<br>            l2 = l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">auto</span> q = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(c);<br>            p-&gt;next = q;<br>            p = q;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="滑动窗口的最大值-239"><a href="#滑动窗口的最大值-239" class="headerlink" title="滑动窗口的最大值(239)"></a>滑动窗口的最大值(<a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239</a>)</h2><p>如果遍历所有数并每次遍历窗口内的数找最大值，那时间复杂度是nk，</p><p>所以我们需要一个双端队列，如果当前这个数加进来比前面的数大，那就可以把它删掉，这样每次的队头元素就是窗口里面的最大值。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        deque&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//双端队列存放的是数的下标</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">size</span>() &amp;&amp; i-k + <span class="hljs-number">1</span> &gt; q.<span class="hljs-built_in">front</span>())   q.<span class="hljs-built_in">pop_front</span>();<br>            <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>() &amp;&amp; nums[i] &gt;= nums[q.<span class="hljs-built_in">back</span>()])   q.<span class="hljs-built_in">pop_back</span>();<br>          <span class="hljs-comment">//每轮队头的元素就是窗口里面最大的。</span><br>            q.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">if</span>(i &gt;= k - <span class="hljs-number">1</span>)  res.<span class="hljs-built_in">push_back</span>(nums[q.<span class="hljs-built_in">front</span>()]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day10</title>
    <link href="/2023/12/10/leetcode-day10/"/>
    <url>/2023/12/10/leetcode-day10/</url>
    
    <content type="html"><![CDATA[<h2 id="爬楼梯-70"><a href="#爬楼梯-70" class="headerlink" title="爬楼梯(70)"></a>爬楼梯(<a href="https://leetcode.cn/problems/climbing-stairs/submissions/488082888/">70</a>)</h2><p>dp，代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-type">int</span> s = a + b;<br>            a = b;<br>            b = s;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="字符串转换整数-8"><a href="#字符串转换整数-8" class="headerlink" title="字符串转换整数(8)"></a>字符串转换整数(<a href="https://leetcode.cn/problems/string-to-integer-atoi/">8</a>)</h2><p>如果开头是字母的话，指针不会往后走，所以会返回默认的0。</p><p>主要考虑符号，以及范围，res要使用long long。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>( k &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[k] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            k++;<br>        &#125;<br>        cout&lt;&lt;k&lt;&lt;endl;<br>        <span class="hljs-keyword">if</span>(k == s.<span class="hljs-built_in">size</span>())   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sym = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(s[k] == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>            sym = <span class="hljs-number">-1</span>;<br>            k++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[k] == <span class="hljs-string">&#x27;+&#x27;</span>)&#123;<br>            sym = <span class="hljs-number">1</span>;<br>            k++;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(k &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[k] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[k]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>            res = res*<span class="hljs-number">10</span> + s[k] - <span class="hljs-string">&#x27;0&#x27;</span>; <br>            k++;<br>            <span class="hljs-keyword">if</span>(res &gt; INT_MAX)   <span class="hljs-keyword">break</span>;<br>        &#125;<br>        res *= sym;<br>        <span class="hljs-keyword">if</span>(res &gt; INT_MAX)   <span class="hljs-keyword">return</span> INT_MAX;<br>        <span class="hljs-keyword">if</span>(res &lt; INT_MIN)   <span class="hljs-keyword">return</span> INT_MIN;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day9</title>
    <link href="/2023/12/09/leetcode-day9/"/>
    <url>/2023/12/09/leetcode-day9/</url>
    
    <content type="html"><![CDATA[<h2 id="排序链表-148"><a href="#排序链表-148" class="headerlink" title="排序链表(148)"></a>排序链表(148)</h2><h2 id="下一个排列-31"><a href="#下一个排列-31" class="headerlink" title="下一个排列(31)"></a>下一个排列(<a href="https://leetcode.cn/problems/next-permutation/description/">31</a>)</h2><p>他会先升序再降序，所以找到第一个使得nums[k-1]&lt;nums[k]的数，如果都是倒序的话，就直接翻转就行。</p><p>然后找到右边降序的第一个比nums[k-1]大的数字。交换，再将降序的序列反转。</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>( k&gt; <span class="hljs-number">0</span> &amp;&amp; nums[k - <span class="hljs-number">1</span>] &gt;= nums[k])  k--;<br>        <span class="hljs-keyword">if</span>(k &lt;= <span class="hljs-number">0</span>)   <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> t = k;<br>            <span class="hljs-keyword">while</span>(t &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[t] &gt; nums[k - <span class="hljs-number">1</span>])    t++;<br>            <span class="hljs-built_in">swap</span>(nums[t - <span class="hljs-number">1</span>],nums[k - <span class="hljs-number">1</span>]);<br>            <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>() + k,nums.<span class="hljs-built_in">end</span>());<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="x的平方根-69"><a href="#x的平方根-69" class="headerlink" title="x的平方根(69)"></a>x的平方根(<a href="https://leetcode.cn/problems/sqrtx/description/">69</a>)</h2><p>二分法：</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = x;<br>        <span class="hljs-keyword">while</span>( l &lt;= r)&#123;<br>            <span class="hljs-type">int</span> mid = (l + r ) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)mid*mid &lt;= x) ans = mid, l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day8</title>
    <link href="/2023/12/08/leetcode-day8/"/>
    <url>/2023/12/08/leetcode-day8/</url>
    
    <content type="html"><![CDATA[<h2 id="删除排序链表中的重复元素II-82"><a href="#删除排序链表中的重复元素II-82" class="headerlink" title="删除排序链表中的重复元素II(82)"></a>删除排序链表中的重复元素II(<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/">82</a>)</h2><p>利用双指针，为了防止头节点也是重复的，我们设立虚拟头节点dummy。然后p = dummy, q = p-&gt;next，每次判断后面的元素是否与q相等，如果相等，找到第一个不相等的，然后让p指向这个节点，并更新q为这个节点。如果不相等，让p，q往后移动一个节点。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>, head);<br>        ListNode *p = dummy;<br>        ListNode *q = dummy-&gt;next;<br>        <span class="hljs-keyword">while</span>(q != <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(q-&gt;next!= <span class="hljs-literal">nullptr</span> &amp;&amp; q-&gt;val == q-&gt;next-&gt;val)&#123; <span class="hljs-comment">//要判断q-&gt;next是不是空了</span><br>                ListNode *t = q-&gt;next;<br>                <span class="hljs-keyword">while</span>(t != <span class="hljs-literal">nullptr</span> &amp;&amp; t-&gt;val == q-&gt;val)&#123; <span class="hljs-comment">//也要判断t是不是空了</span><br>                    t = t-&gt;next;<br>                &#125;<br>                q = t;<br>                p-&gt;next = q;<br>            &#125; <br>            <span class="hljs-keyword">else</span>&#123;<br>                p = q;<br>                q = p-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="复原IP地址-93"><a href="#复原IP地址-93" class="headerlink" title="复原IP地址(93)"></a>复原IP地址(<a href="https://leetcode.cn/problems/restore-ip-addresses/description/">93</a>)</h2><p>回溯，感觉这种递归都是对某个位置进行递归。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string&amp; s ,<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> k, string path)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(u == s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(k == <span class="hljs-number">4</span>)&#123;<br>                path.<span class="hljs-built_in">pop_back</span>();<br>                res.<span class="hljs-built_in">push_back</span>(path);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">4</span>)  <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = u, t = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>          <span class="hljs-comment">//如果0开头的是不符合的，直接break</span><br>            <span class="hljs-keyword">if</span>(i &gt; u &amp;&amp; s[u] == <span class="hljs-string">&#x27;0&#x27;</span>)    <span class="hljs-keyword">break</span>;<br>            t = t * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(t &lt;= <span class="hljs-number">255</span>)    <span class="hljs-built_in">dfs</span>(s,i+<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>,path+<span class="hljs-built_in">to_string</span>(t)+<span class="hljs-string">&#x27;.&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;   <br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day7</title>
    <link href="/2023/12/07/leetcode-day7/"/>
    <url>/2023/12/07/leetcode-day7/</url>
    
    <content type="html"><![CDATA[<h2 id="二分查找-704"><a href="#二分查找-704" class="headerlink" title="二分查找(704)"></a>二分查找(<a href="https://leetcode.cn/problems/binary-search/description/">704</a>)</h2><p>简单题，用的y总的模版。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &gt;= target) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>( nums[r] == target)  <span class="hljs-keyword">return</span> r;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="二叉树的右视图-199"><a href="#二叉树的右视图-199" class="headerlink" title="二叉树的右视图(199)"></a>二叉树的右视图(<a href="https://leetcode.cn/problems/binary-tree-right-side-view/submissions/487490495/">199</a>)</h2><p>答案就是将二叉树每一层的最右边元素返回，层序遍历的模版，只要保存每一层最后一个元素即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        queue&lt;TreeNode*&gt; q;<br>        <span class="hljs-keyword">if</span>(!root)   <span class="hljs-keyword">return</span> res;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-type">int</span> n = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>                <span class="hljs-keyword">auto</span> e = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(i == n - <span class="hljs-number">1</span>)  res.<span class="hljs-built_in">push_back</span>(e-&gt;val);<br>                <span class="hljs-keyword">if</span>(e-&gt;left) q.<span class="hljs-built_in">push</span>(e-&gt;left);<br>                <span class="hljs-keyword">if</span>(e-&gt;right) q.<span class="hljs-built_in">push</span>(e-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="232-用栈实现队列-232"><a href="#232-用栈实现队列-232" class="headerlink" title="232 用栈实现队列(232)"></a>232 用栈实现队列(<a href="https://leetcode.cn/problems/implement-queue-using-stacks/submissions/487494409/">232</a>)</h2><p>简单题，两个栈A，B，入队列就是入A，出队列就是出B，如果B空，将A的元素弹出放入B中即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; A;<br>    stack&lt;<span class="hljs-type">int</span>&gt; B;<br><br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        A.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> e = <span class="hljs-built_in">peek</span>();<br>        B.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> e;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!B.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">return</span> B.<span class="hljs-built_in">top</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">empty</span>())   <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">while</span>(!A.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-keyword">auto</span> e = A.<span class="hljs-built_in">top</span>();<br>                A.<span class="hljs-built_in">pop</span>();<br>                B.<span class="hljs-built_in">push</span>(e);<br>                &#125;<br>            <span class="hljs-keyword">return</span> B.<span class="hljs-built_in">top</span>();<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">empty</span>() &amp;&amp; B.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="寻找两个正序数组的中位数-4"><a href="#寻找两个正序数组的中位数-4" class="headerlink" title="寻找两个正序数组的中位数(4)"></a>寻找两个正序数组的中位数(<a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4</a>)</h2><p>采用递归的方法，每次找到数组1和数组2的第k/2个元素，比较他们的大小，</p><p>如果nums1[k/2]  &lt; nums2[k/2]，则说明第k个数肯定不会出现在 num1中前k/2个数里，所以我们可以将num1的前k/2个数抛弃掉，再重新递归剩下的数。nums1[k/2]&gt; nums2[k/2]同理。当nums1[k/2] ==  nums2[k/2]的时候，这两个数前面刚好有k-2个数，第k个数就是他们。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> tot = nums1.<span class="hljs-built_in">size</span>() + nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(tot % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> l = <span class="hljs-built_in">find</span>(nums1,<span class="hljs-number">0</span>,nums2,<span class="hljs-number">0</span>, tot / <span class="hljs-number">2</span>);<br>            <span class="hljs-type">int</span> r = <span class="hljs-built_in">find</span>(nums1,<span class="hljs-number">0</span>,nums2,<span class="hljs-number">0</span>, tot / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> ( l + r) / <span class="hljs-number">2.0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, tot / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">find</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> i, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span></span>&#123;<br>        <span class="hljs-comment">//让第一个数组是短的那个</span><br>        <span class="hljs-keyword">if</span>(nums1.<span class="hljs-built_in">size</span>() - i &gt; nums2.<span class="hljs-built_in">size</span>() - j) <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(nums2,j, nums1,i, k);<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(nums1.<span class="hljs-built_in">size</span>() == i)   <span class="hljs-keyword">return</span> nums2[j];<br>            <span class="hljs-keyword">else</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(nums1[i], nums2[j]);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums1.<span class="hljs-built_in">size</span>() == i)   <span class="hljs-keyword">return</span> nums2[j + k - <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> si = <span class="hljs-built_in">min</span>((<span class="hljs-type">int</span>)nums1.<span class="hljs-built_in">size</span>(), i + k / <span class="hljs-number">2</span>), sj = j + k - k / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//si是第k/2个元素的后一个元素，所以要减1</span><br>        <span class="hljs-keyword">if</span>(nums1[si - <span class="hljs-number">1</span>] &gt; nums2[sj - <span class="hljs-number">1</span>])    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(nums1,i,nums2,sj,k - (sj - j));<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(nums1,si, nums2,j,k-(si-i));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day6</title>
    <link href="/2023/12/06/leetcode-day6/"/>
    <url>/2023/12/06/leetcode-day6/</url>
    
    <content type="html"><![CDATA[<h2 id="编辑距离-72"><a href="#编辑距离-72" class="headerlink" title="编辑距离(72)"></a>编辑距离(<a href="https://leetcode.cn/problems/edit-distance/description/">72</a>)</h2><p>动态规划，这里是y总的思路。</p><p>dp [i] [j] 代表的是按顺序将A[1-i]变成B[1-j]所需要的步数，属性就是最小值。</p><p><img src="https://raw.githubusercontent.com/yanzhang404/Image/main/%E6%88%AA%E5%B1%8F2023-12-06%2021.23.03.png" alt="截屏2023-12-06 21.23.03"></p><span id="more"></span><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = word1.<span class="hljs-built_in">size</span>(), m = word2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m+<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">//小技巧让字符串从1开始</span><br>        word1 = <span class="hljs-string">&#x27; &#x27;</span> + word1;<br>        word2 = <span class="hljs-string">&#x27; &#x27;</span> + word2;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)  dp[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)  dp[<span class="hljs-number">0</span>][i] = i;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;<br>                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>])+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> p = word1[i] != word2[j];<br>                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+p,dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="中序遍历-94"><a href="#中序遍历-94" class="headerlink" title="中序遍历(94)"></a>中序遍历(<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">94</a>)</h2><p>递归写法很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<span class="hljs-comment">//写个辅助函数</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)   <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>非递归写法：</p><p>维护一个栈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)   <span class="hljs-keyword">return</span> res;<br>        stack&lt;TreeNode*&gt; stk;<br>        <span class="hljs-keyword">while</span>(root || stk.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">while</span>(root)&#123;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">size</span>())&#123;<br>                root = stk.<span class="hljs-built_in">top</span>();<br>                stk.<span class="hljs-built_in">pop</span>();<br>                res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                root = root-&gt;right; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最长公共子序列-1143"><a href="#最长公共子序列-1143" class="headerlink" title="最长公共子序列(1143)"></a>最长公共子序列(<a href="https://leetcode.cn/problems/edit-distance/">1143</a>)</h2><p><img src="https://raw.githubusercontent.com/yanzhang404/Image/main/截屏2023-12-06 22.12.35.png" alt="截屏2023-12-06 22.12.35"></p><p>当i在j不在的时候，f(i, j) !=f(i,j-1)， 因为f(i, j -1)是到第i和第j-1中的最大公共子序列，i可能在里面也可能不在里面。</p><p>所以包含了f(i-1, j-1)，但是因为求最大值，所以无所谓重复。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = text1.<span class="hljs-built_in">size</span>(), m = text2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m+<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>                <span class="hljs-keyword">if</span>(text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>])    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day5</title>
    <link href="/2023/12/05/leetcode-day5/"/>
    <url>/2023/12/05/leetcode-day5/</url>
    
    <content type="html"><![CDATA[<h2 id="环形链表II-142"><a href="#环形链表II-142" class="headerlink" title="环形链表II(142)"></a>环形链表II(<a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142</a>)</h2><p>之前的环形链表只要求判断，这个需要我们找到环的入口，也很巧妙。</p><p>如图，假设a为链表头，b为环的入口，c为快慢指针相遇的节点，假设慢指针回退y个节点到b，那么快指针会回退2y个节点，假设到c‘点。再假设慢指针走了x步到b点，则快指针走了2x步，也就是从b到c‘一共长x。那这个环其实就是x+y步长，那么因为b到c是y步，那么c再到b就是x(绿色线)，也就是说，让一个指针从a出发，另一个指针从c出发，走x步他们都会走到b，也就是环的入口。</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/yanzhang404/Image/main/%E6%88%AA%E5%B1%8F2023-12-05%2019.04.28.png" alt="截屏2023-12-05 19.04.28"></p><p>只要将I的代码稍作修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode* p = head;<br>         ListNode* q = head;<br>        <span class="hljs-keyword">while</span>(q)&#123;<br>            p = p-&gt;next, q = q-&gt;next;<br>            <span class="hljs-keyword">if</span>(!q) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            q = q-&gt;next;<br>            <span class="hljs-keyword">if</span>(p == q)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>      <span class="hljs-comment">//没有环的时候或者相遇都会到这一步，因此要判断如果q为空指针则返回null</span><br>        <span class="hljs-keyword">if</span>(q == <span class="hljs-literal">nullptr</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>      <span class="hljs-comment">//否则让p从head开始，q从相遇点开始往后，当他们相等的时候就是环的入口。</span><br>        p = head;<br>        <span class="hljs-keyword">while</span>(p != q)&#123;<br>            p = p-&gt;next;<br>            q = q-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> q;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="接雨水-42"><a href="#接雨水-42" class="headerlink" title="*接雨水(42)"></a>*接雨水(<a href="https://leetcode.cn/problems/trapping-rain-water/">42</a>)</h2><p>看了y总讲的方法，也就是维护一个栈，遍历每个柱子的高度，如果比栈中的高度高，那么就可以计算可以盛水的量。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk; <span class="hljs-comment">//存的是小的下标</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-type">int</span> last = <span class="hljs-number">0</span>;<span class="hljs-comment">//代表上一个柱子的高度，每次从0开始</span><br>            <span class="hljs-keyword">while</span>(stk.<span class="hljs-built_in">size</span>() &amp;&amp; height[stk.<span class="hljs-built_in">top</span>()] &lt; height[i])&#123;<br>                res += (height[stk.<span class="hljs-built_in">top</span>()] - last) * (i - stk.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>); <span class="hljs-comment">//高度乘宽度</span><br>                last = height[stk.<span class="hljs-built_in">top</span>()];<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>          <span class="hljs-comment">//如果遇到存在栈里的比当前柱子要高的，还要再计算一次</span><br>            <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">size</span>()) res += (i - stk.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>) * (height[i] - last);<br>          <span class="hljs-comment">//将当前柱子放到栈中。</span><br>            stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="删除链表倒数第N个节点-19"><a href="#删除链表倒数第N个节点-19" class="headerlink" title="删除链表倒数第N个节点(19)"></a>删除链表倒数第N个节点(<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19</a>)</h2><p>要找到倒数第n个节点，设立两个指针p，q，先让q走到正数第n个节点，然后p，q同时移动，当q走到最后一个节点的时候，p就走到了倒数第n个节点。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode* p = head;<br>        ListNode* q = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            q = q-&gt;next;<br>        &#125;<br>      <span class="hljs-comment">//删除的是第一个节点，那么直接让head=head-&gt;next</span><br>        <span class="hljs-keyword">if</span>(q == <span class="hljs-literal">nullptr</span>)&#123;<br>            head = head-&gt;next;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(q-&gt;next != <span class="hljs-literal">NULL</span>)&#123;<br>            p = p-&gt;next;<br>            q = q-&gt;next;<br>        &#125;<br>        q = p-&gt;next;<br>        p-&gt;next = q-&gt;next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="合并区间-56"><a href="#合并区间-56" class="headerlink" title="合并区间(56)"></a>合并区间(<a href="https://leetcode.cn/problems/merge-intervals/submissions/487003354/">56</a>)</h2><p>模板题，按照区间左端点排序，然后遍历每个区间，每次判断第i个区间的左端点和当前区间的右端点的大小，如果大于，则将当前区间加入答案，将当前区间更新为第i个区间；如果小，则更新当前区间的右端点为大的那个。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>      <span class="hljs-comment">//vector可以直接排序，按照每个vector里的第一个元素</span><br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> l = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],r = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &gt; r)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>                l = intervals[i][<span class="hljs-number">0</span>], r = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span>    r = <span class="hljs-built_in">max</span>(r,intervals[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树的最大路径和-124"><a href="#二叉树的最大路径和-124" class="headerlink" title="*二叉树的最大路径和(124)"></a>*二叉树的最大路径和(<a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/">124</a>)</h2><p>我们遍历的是每个路径的最高点，也就是LCA，最近公共祖先，最长的路径肯定是左边的最长+右边的最长加根的值。</p><blockquote><p>按照题意：一颗三个节点的小树的结果只可能有如下6种情况：</p><ol><li>根 + 左 + 右</li><li>根 + 左</li><li>根 + 右</li><li>根</li><li>左</li><li>右</li></ol><p>好了，分析上述6种情况， 只有 2,3,4 可以向上累加，而1,5,6不可以累加（这个很好想，情况1向上累加的话，必然出现分叉，也就说明当前根不是LCA，矛盾；情况5和6直接就跟上面的树枝断开的，没法累加），所以我们找一个全局变量存储 1,5,6这三种不可累加的最大值， 另一方面咱们用遍历树的方法求2,3,4这三种可以累加的情况。 最后把两类情况得到的最大值再取一个最大值即可。<br>–来自lc评论</p></blockquote><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        ans = INT_MIN;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">dfs</span>(root-&gt;left)), r = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">dfs</span>(root-&gt;right));<br>        ans = <span class="hljs-built_in">max</span>(ans,root-&gt;val + l + r);<br>        <span class="hljs-keyword">return</span> root-&gt;val + <span class="hljs-built_in">max</span>(l, r );<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>代码很简洁，但要搞懂这个思路。</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day4</title>
    <link href="/2023/12/04/leetcode-day4/"/>
    <url>/2023/12/04/leetcode-day4/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串相加-415"><a href="#字符串相加-415" class="headerlink" title="字符串相加(415)"></a>字符串相加(<a href="https://leetcode.cn/problems/add-strings/description/">415</a>)</h2><p>就是字符串来模拟数字相加，每次计算低位，并进位（有的话），然后一直加到高位。</p><p>代码：</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addStrings</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = num1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, j = num2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,  carry = <span class="hljs-number">0</span>;<br>        string res;<br>        <span class="hljs-keyword">while</span>( i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span>  n1 = i &gt;= <span class="hljs-number">0</span> ? num1[i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span>  n2 = j &gt;= <span class="hljs-number">0</span> ? num2[j] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> temp = n1 + n2 + carry;<br>            carry = temp / <span class="hljs-number">10</span>;<br>            res += (temp % <span class="hljs-number">10</span>) + <span class="hljs-string">&#x27;0&#x27;</span>;<br>            i--;<br>            j--;<br>        &#125;<br>      <span class="hljs-comment">//如果最后有进位，res要加上它</span><br>        <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>)  res += <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-comment">//再将答案反转</span><br>      <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最长递增子序列-300"><a href="#最长递增子序列-300" class="headerlink" title="最长递增子序列(300)"></a>最长递增子序列(<a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">300</a>)</h2><p>n^2的用dp做，nlogn用贪心做。</p><p>dp代码很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(),<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//以nums[i]结尾的最长子序列的长度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j] &lt; nums[i])   dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>贪心做法是，开辟一个数组，数组下标为i的数代表长度为i的子序列的最后一个数。这是一个严格单调递增的数列，对于nums中的每个数，找到<strong>子序列最后一个数比他小的最长的那个子序列</strong>，并将后一个数更新为它。可以使用二分法做。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//长度为i的子序列的最后一个元素。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : nums)&#123;<br>            <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">empty</span>() || x &gt; q.<span class="hljs-built_in">back</span>())   q.<span class="hljs-built_in">push_back</span>(x);<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(x &lt;= q[<span class="hljs-number">0</span>])    q[<span class="hljs-number">0</span>] = x;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = q.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">while</span>( l &lt; r)&#123;<br>                        <span class="hljs-type">int</span> mid = (l + r + <span class="hljs-number">1</span>)&gt;&gt; <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">if</span>(q[mid] &lt; x)  l = mid;<br>                        <span class="hljs-keyword">else</span>    r = mid - <span class="hljs-number">1</span>;<br>                    &#125;<br>                    q[r + <span class="hljs-number">1</span>] = x;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//q的长度就是最长子序列的长度</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个做法有点帅，用时大大下降。</p><p><img src="https://raw.githubusercontent.com/yanzhang404/Image/main/xx.png" alt="xx"></p><h2 id="重排链表-143"><a href="#重排链表-143" class="headerlink" title="重排链表(143)"></a>重排链表(<a href="https://leetcode.cn/problems/reorder-list/description/">143</a>)</h2><p>本题是三个操作的结合，分别是找到链表中点，反转右边的链表，再将两个链表结合。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">//找中点</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        ListNode* mid = <span class="hljs-built_in">FindMiddle</span>(head);<br>        ListNode* l1 = head;<br>        ListNode* l2 = mid-&gt;next;<br>        mid-&gt;next = <span class="hljs-literal">NULL</span>;<br>        l2 = <span class="hljs-built_in">reverseList</span>(l2);<br>        head = <span class="hljs-built_in">mergeList</span>(l1, l2);<br>    &#125;<br><span class="hljs-comment">//寻找链表中点</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindMiddle</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        ListNode *slow = head;<br>        ListNode *fast = head;<br>        <span class="hljs-keyword">while</span>(fast-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="hljs-literal">nullptr</span>)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>    <span class="hljs-comment">//反转链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        ListNode* curr = head;<br>        ListNode* prev = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(curr != <span class="hljs-literal">nullptr</span>)&#123;<br>            ListNode* r = curr-&gt;next;<br>            curr-&gt;next = prev;<br>            prev = curr;<br>            curr = r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br><br><br><span class="hljs-comment">//合并两个链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeList</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span></span>&#123;<br>        ListNode* p = l1;<br>        ListNode* q = l2;<br>        <span class="hljs-keyword">while</span>(q != <span class="hljs-literal">nullptr</span>)&#123;<br>            ListNode* s = q-&gt;next;<br>            q-&gt;next = p-&gt;next; <br>            p-&gt;next = q;<br>            p = q-&gt;next;<br>            q = s;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day3</title>
    <link href="/2023/12/03/leetcode-day3/"/>
    <url>/2023/12/03/leetcode-day3/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树的最近公共祖先-236"><a href="#二叉树的最近公共祖先-236" class="headerlink" title="二叉树的最近公共祖先(236)"></a>二叉树的最近公共祖先(<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236</a>)</h2><p>在做这题之前先看前一题(235)，二叉搜索树的最近公共祖先，因为二叉搜索树左子树小于根小于右子树，所以递归的时候更简单。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;val &gt; q-&gt;val) <span class="hljs-built_in">swap</span>(p,q);<span class="hljs-comment">//让p指向小的那个</span><br>        <span class="hljs-keyword">if</span>(p-&gt;val &lt;=root-&gt;val &amp;&amp; q-&gt;val &gt;=root-&gt;val)    <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span>(p-&gt;val &lt;root-&gt;val &amp;&amp; q-&gt;val &lt;root-&gt;val)  <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>而如果不是二叉搜索树，那就要都遍历一遍，代码：</p><span id="more"></span><p>函数的返回值有四种情况，</p><p>如果root为空，贼返回root</p><p>如果只包含p，则返回p，</p><p>如果只包含q，则返回q，</p><p>如果包含p和q则返回root。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>      <span class="hljs-comment">//如果root为空或者root为p或q，则直接返回root</span><br>        <span class="hljs-keyword">if</span>(!root || root ==p || root == q)  <span class="hljs-keyword">return</span> root;<br>      <span class="hljs-comment">//查看左子树的返回值，</span><br>        <span class="hljs-keyword">auto</span> left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);<br>        <span class="hljs-keyword">auto</span> right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);<br>        <span class="hljs-keyword">if</span>(!left)   <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">if</span>(!right)  <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;   <br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="全排列-46"><a href="#全排列-46" class="headerlink" title="全排列(46)"></a>全排列(<a href="https://leetcode.cn/problems/permutations/description/">46</a>)</h2><p>需要对排列的每个位置进行枚举，需要一个path数组保存排列，一个st数组判断元素是否被用过。代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; st;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        path = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums.<span class="hljs-built_in">size</span>());<br>        st = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(nums.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>);<span class="hljs-comment">//对每个位置进行枚举</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> u)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(u == nums.<span class="hljs-built_in">size</span>())    ans.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(st[i] == <span class="hljs-literal">false</span>)&#123;<br>                st[i] = <span class="hljs-literal">true</span>;<br>                path[u] = nums[i];<br>                <span class="hljs-built_in">dfs</span>(nums,u+<span class="hljs-number">1</span>);<br>                st[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="螺旋矩阵-54"><a href="#螺旋矩阵-54" class="headerlink" title="螺旋矩阵(54)"></a>螺旋矩阵(<a href="https://leetcode.cn/problems/spiral-matrix/description/">54</a>)</h2><p>利用dx和dy对方向进行修改，都是按照右，下，左，上的顺序搜索，数组的坐标是x朝下，y朝右，所以dx={0,1,0,-1}，dy={1,0,-1,0}。每次只要越界或者那个数已经遍历过，则修改方向。所以还需要一个st判断是否遍历过。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">st</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, x = <span class="hljs-number">0</span>,y = <span class="hljs-number">0</span>, d =<span class="hljs-number">0</span>; i &lt; m*n; i++)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(matrix[x][y]);<br>            st[x][y] = <span class="hljs-literal">true</span>;<br>          <span class="hljs-comment">//将当前位置添加后，判断下一个数是否需要改变方向</span><br>            <span class="hljs-type">int</span> a = x + dx[d], b = y + dy[d];<br>            <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m || st[a][b])&#123;<br>                d = (d + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<span class="hljs-comment">//按照0，1，2，3，0，1，2，3顺序</span><br>                a = x+dx[d], b = y+dy[d];<br>            &#125;<br>          <span class="hljs-comment">//更新x,y</span><br>            x = a ,y = b;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="反转链表II-92"><a href="#反转链表II-92" class="headerlink" title="反转链表II (92)"></a>反转链表II (<a href="https://leetcode.cn/problems/reverse-linked-list-ii/description/">92</a>)</h2><p>要找到left和right位置的节点，并保存left的前一个节点和right的后一个节点。然后将left到right反转，让left前一个节点指向新的left节点即可，为了考虑left为头节点的情况，我们可以加一个假的头节点dummy。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>,head);<br>        <span class="hljs-keyword">if</span>(left == right)   <span class="hljs-keyword">return</span> dummy-&gt;next;<br>        ListNode* p = dummy;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++)&#123;<br>            p = p-&gt;next;<span class="hljs-comment">//p是left前一个节点</span><br>        &#125;<br>        ListNode* l = p-&gt;next; <span class="hljs-comment">//l是left节点</span><br>        ListNode* r = dummy;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; right; i++)&#123;<br>            r = r-&gt;next;<br>        &#125;<br>        ListNode* s = r-&gt;next;<br>        r-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(l != <span class="hljs-literal">nullptr</span>)&#123;<br>            ListNode * t = l-&gt;next;<span class="hljs-comment">//保存l的下一个节点</span><br>            l-&gt;next = s;<br>            s = l;<br>            l = t;<br>        &#125;<br>        p-&gt;next = s;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相交链表-160"><a href="#相交链表-160" class="headerlink" title="相交链表(160)"></a>相交链表(<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160</a>)</h2><p>就是让p，q分别指向headA和headB，如果p为空了，让p重新指向headB再走，q同理，因为到交点走的路径是相同的，所以肯定会走到交点，如果没有交点，全部走一遍后，两个指针指向null，则也成立。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode* p = headA;<br>        ListNode* q = headB;<br>        <span class="hljs-keyword">while</span>(q != p)&#123;<br>            p = p ? p-&gt;next : headB;<br>            q = q ? q-&gt;next : headA;<br>        &#125;<br>        <span class="hljs-keyword">return</span> q; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="合并K个升序链表-23"><a href="#合并K个升序链表-23" class="headerlink" title="合并K个升序链表(23)"></a>合并K个升序链表(<a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">23</a>)</h2><p>采用了小根堆的方法，每次将堆顶元素取出来，如果有next元素，再把他放到小根堆里。用到了priority_queue，需要重写比较，因为priority_queue 默认是大根堆，所以要重写一个cmp，传入Cmp的结构体。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cmp</span>&#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(ListNode* a, ListNode* b)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> a-&gt;val &gt; b-&gt;val;<span class="hljs-comment">//这里大于号创建小根堆</span><br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, Cmp&gt; heap;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), tail = dummy;<br>      <span class="hljs-comment">//先将所有节点存入堆中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> l : lists) <span class="hljs-keyword">if</span>(l) heap.<span class="hljs-built_in">push</span>(l);<br><br>        <span class="hljs-keyword">while</span>(heap.<span class="hljs-built_in">size</span>())&#123;<br>          <span class="hljs-comment">//弹出堆顶元素，即最小值，再将next元素放到堆中。</span><br>            <span class="hljs-keyword">auto</span> e = heap.<span class="hljs-built_in">top</span>();<br>            heap.<span class="hljs-built_in">pop</span>();<br>            tail-&gt;next = e;<br>            tail = e;<br>            <span class="hljs-keyword">if</span>(e-&gt;next) heap.<span class="hljs-built_in">push</span>(e-&gt;next);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day2</title>
    <link href="/2023/12/02/leetcode_day2/"/>
    <url>/2023/12/02/leetcode_day2/</url>
    
    <content type="html"><![CDATA[<h2 id="最长回文子串-5"><a href="#最长回文子串-5" class="headerlink" title="最长回文子串(5)"></a>最长回文子串(<a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">5</a>)</h2><p>本题字符串长度1000，则n方的时间复杂度即可，即枚举法，对回文串的中心进行枚举，两个指针向左右两边枚举，分两种情况，奇数的回文串和偶数的回文串。最后返回最长的那个。</p><span id="more"></span><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-comment">//奇数长度的回文串</span><br>            <span class="hljs-type">int</span> l = i - <span class="hljs-number">1</span>, r = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>( l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt;s.<span class="hljs-built_in">size</span>() &amp;&amp; s[l] == s[r]) l-- ,r++;<br>            <span class="hljs-comment">//循环完后子串即 l+1 到 r-1的子串</span><br>            <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() &lt; r - l - <span class="hljs-number">1</span>) res = s.<span class="hljs-built_in">substr</span>(l + <span class="hljs-number">1</span>, r - l <span class="hljs-number">-1</span>);<br>            <span class="hljs-comment">//偶数长度的回文串</span><br>            l = i, r = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>( l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt;s.<span class="hljs-built_in">size</span>() &amp;&amp; s[l] == s[r]) l-- ,r++;<br>            <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() &lt; r - l - <span class="hljs-number">1</span>) res = s.<span class="hljs-built_in">substr</span>(l + <span class="hljs-number">1</span>, r - l <span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果将长度扩展到10^6，则可以采用二分加哈希。</p><p>另外，可以通过特殊处理将偶数回文串或者奇数回文串都变成奇数回文串。</p><p>通过二分查找边界。</p><h2 id="二叉树的层序遍历-102"><a href="#二叉树的层序遍历-102" class="headerlink" title="二叉树的层序遍历(102)"></a>二叉树的层序遍历(<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102</a>)</h2><p>利用队列，跟广度优先差不多，之前一直在想每一层的个数怎么求，其实就是每一次循环的时候的队列长度len。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        queue&lt;TreeNode*&gt; q;<br><br>        <span class="hljs-keyword">if</span>(root)&#123; <span class="hljs-comment">//根节点非空，放入队列</span><br>            q.<span class="hljs-built_in">push</span>(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123; <span class="hljs-comment">//队列非空时循环</span><br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 即每层的个数</span><br>            vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>            <span class="hljs-keyword">while</span>(len--)&#123;<br>                <span class="hljs-keyword">auto</span> e = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(e-&gt;left)  q.<span class="hljs-built_in">push</span>(e-&gt;left);<br>                <span class="hljs-keyword">if</span>(e-&gt;right)  q.<span class="hljs-built_in">push</span>(e-&gt;right);<br>                temp.<span class="hljs-built_in">push_back</span>(e-&gt;val);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="搜索旋转排序数组-33"><a href="#搜索旋转排序数组-33" class="headerlink" title="搜索旋转排序数组(33)"></a>搜索旋转排序数组(<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">33</a>)</h2><p>考察二分，而且需要两次二分，因为是两段单调递增的数，二分就是要找一个条件使得一个区间满足，另一个区间不满足，本题找到旋转点，左边区间肯定满足比左边第一个数大，右边区间满足比第一个数小，则按此条件二分。</p><p>对于二分的两个模板，此题也是一个有助于理解的，因为两个模板都用到了，比如第一次二分，要找分界点，也就是找比nums[0]大的最大的那个数，区间即<strong>ooooo@xxxxxx</strong>，<strong>o和@代表满足条件的数</strong>，<strong>@是最后的答案</strong>，是右端点，因此如果check(mid)为真，即mid是o，那只能让l=mid，如果让r=mid，就把@排除了。同理第二次二分要找到target，我们还是令条件为&gt;=target，那要找的数就是满足条件的最小的数，<strong>xxxxxx@oooooo</strong>，就是这种情况，@是左边界，那如果check(mid)为真，mid为o，那只能让r = mid，如果l=mid，同样将@排除在外了。这也是所谓的二分的边界了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &gt;= nums[<span class="hljs-number">0</span>])    l = mid;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(target &gt;= nums[<span class="hljs-number">0</span>])   l = <span class="hljs-number">0</span>; <span class="hljs-comment">//看看target在哪个区间里</span><br>        <span class="hljs-keyword">else</span> l = r + <span class="hljs-number">1</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>      <br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> mid  = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &gt;= target) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125; <br>        <span class="hljs-keyword">if</span>( nums[r] == target)  <span class="hljs-keyword">return</span> r;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="环形链表-141"><a href="#环形链表-141" class="headerlink" title="环形链表(141)"></a>环形链表(<a href="https://leetcode.cn/problems/linked-list-cycle/description/">141</a>)</h2><p>两个指针，一个 每次移动1个节点，另一个移动2个节点，有环的话最后会相遇的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>         ListNode* p = head;<br>         ListNode* q = head;<br>        <span class="hljs-keyword">while</span>(q)&#123; <span class="hljs-comment">//q走的快，判断q是不是空即可</span><br>            p = p-&gt;next, q = q-&gt;next;<br>            <span class="hljs-keyword">if</span>(!q) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//q为空直接返回false</span><br>            q = q-&gt;next;<br>            <span class="hljs-keyword">if</span>(p == q)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机-121"><a href="#买卖股票的最佳时机-121" class="headerlink" title="买卖股票的最佳时机(121)"></a>买卖股票的最佳时机(<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121</a>)</h2><p>遍历一遍，minp代表第i个数前面的数中的最小值，可以在每次遍历的时候更新，答案就是当前数与前面最小数之间的差。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, minp= INT_MAX; i &lt; prices.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res, prices[i] - minp);<br>            minp = <span class="hljs-built_in">min</span>(minp, prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="岛屿数量-200"><a href="#岛屿数量-200" class="headerlink" title="岛屿数量(200)"></a>岛屿数量(<a href="https://leetcode.cn/problems/number-of-islands/description/">200</a>)</h2><p>flood fill类的题目，对每个位置进行广搜或者深搜即可。如果当前位置没搜过，则对他进行深度搜索，即对上下左右四个位置进行搜索。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-comment">//定义全局变量</span><br>    vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; g;<br>  <span class="hljs-comment">//定义dx，dy方便枚举4个方向的数</span><br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;; <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        g = grid;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; g.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; g[i].<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(g[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    <span class="hljs-built_in">dfs</span>(i,j);<br>                    res++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        g[x][y] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>            <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>            <span class="hljs-keyword">if</span>(a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; g.<span class="hljs-built_in">size</span>() &amp;&amp; b &gt;= <span class="hljs-number">0</span> &amp;&amp; b&lt; g[a].<span class="hljs-built_in">size</span>() &amp;&amp; g[a][b] == <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-comment">//判断是否越界</span><br>                <span class="hljs-built_in">dfs</span>(a,b);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="有效的括号-20"><a href="#有效的括号-20" class="headerlink" title="有效的括号(20)"></a>有效的括号(<a href="https://leetcode.cn/problems/valid-parentheses/description/">20</a>)</h2><p>利用栈，对每个字符进行判断即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; p;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : s)&#123;<br>            <br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-string">&#x27;(&#x27;</span> || i == <span class="hljs-string">&#x27;[&#x27;</span> || i == <span class="hljs-string">&#x27;&#123;&#x27;</span>)    p.<span class="hljs-built_in">push</span>(i);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( i == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(p.<span class="hljs-built_in">empty</span>())  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">auto</span> e = p.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-keyword">if</span>(e == <span class="hljs-string">&#x27;[&#x27;</span> || e == <span class="hljs-string">&#x27;&#123;&#x27;</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                p.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( i == <span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(p.<span class="hljs-built_in">empty</span>())  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">auto</span> e = p.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-keyword">if</span>(e == <span class="hljs-string">&#x27;(&#x27;</span> || e == <span class="hljs-string">&#x27;&#123;&#x27;</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                p.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( i == <span class="hljs-string">&#x27;&#125;&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(p.<span class="hljs-built_in">empty</span>())  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">auto</span> e = p.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-keyword">if</span>(e == <span class="hljs-string">&#x27;[&#x27;</span> || e == <span class="hljs-string">&#x27;(&#x27;</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                p.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!p.<span class="hljs-built_in">empty</span>())  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>好像也可以用哈希，我这里直接判断也过了。</p><h2 id="合并两个有序数组-88"><a href="#合并两个有序数组-88" class="headerlink" title="合并两个有序数组(88)"></a>合并两个有序数组(<a href="https://leetcode.cn/problems/merge-sorted-array/description/">88</a>)</h2><p>很简单的归并题，但题目提到了nums1的长度上m+n，我一开始开了一个新的数组复制nums1的前m个，然后从前往后按归并的方法做，但后来发现不需要开辟新的数组，只要从后往前就可以了，先把大的数放到数组后面就行。时间超过100%</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = m - <span class="hljs-number">1</span>, j = n - <span class="hljs-number">1</span>, k = m + n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>)&#123;<br>            nums1[k--] = nums1[i] &gt; nums2[j] ? nums1[i--] : nums2[j--];<br>        &#125;<br>        <span class="hljs-keyword">while</span>( i &gt;= <span class="hljs-number">0</span>)&#123;<br>            nums1[k--] = nums1[i--];<br>        &#125;<br>        <span class="hljs-keyword">while</span>( j&gt;= <span class="hljs-number">0</span>)&#123;<br>            nums1[k--] = nums2[j--];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树的锯齿形层序遍历-103"><a href="#二叉树的锯齿形层序遍历-103" class="headerlink" title="二叉树的锯齿形层序遍历(103)"></a>二叉树的锯齿形层序遍历(<a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/">103</a>)</h2><p>就是先写层序遍历，如果是第2i+1层（从第0层开始）的话就反转一下就行。</p><p>我一开始想着按层判断先加左孩子还是先加右孩子，但这样其实是错的，后面就都乱了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        queue&lt;TreeNode*&gt; q;<br>        <span class="hljs-keyword">if</span>(root)    q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> floor = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(len--)&#123;<br>                <span class="hljs-keyword">auto</span> e = q.<span class="hljs-built_in">front</span>();<br>                temp.<span class="hljs-built_in">push_back</span>(e-&gt;val);<br>                <span class="hljs-keyword">if</span>(e-&gt;left)     q.<span class="hljs-built_in">push</span>(e-&gt;left);<br>                <span class="hljs-keyword">if</span>(e-&gt;right)    q.<span class="hljs-built_in">push</span>(e-&gt;right);<br>                q.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(floor % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)  <span class="hljs-built_in">reverse</span>(temp.<span class="hljs-built_in">begin</span>(),temp.<span class="hljs-built_in">end</span>());<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            floor++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day1</title>
    <link href="/2023/12/01/leetcode_day1/"/>
    <url>/2023/12/01/leetcode_day1/</url>
    
    <content type="html"><![CDATA[<h2 id="三数之和-15"><a href="#三数之和-15" class="headerlink" title="三数之和(15)"></a>三数之和(<a href="https://leetcode.cn/problems/3sum/description/">15</a>)</h2><p>采用双指针算法，先将数组排序，并确保i&lt;j&lt;k，固定i后对j和k是双指针。</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//因为排序过了，如果i和i-1相同则情况一样，跳过</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k = n <span class="hljs-number">-1</span>; j &lt; k; j++)&#123;<br>                <span class="hljs-keyword">if</span>(j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>])   <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//同理</span><br>                <span class="hljs-keyword">while</span>(j &lt; k - <span class="hljs-number">1</span> &amp;&amp; nums[i] + nums[j] + nums[k - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>) k--;<br>                <span class="hljs-keyword">if</span>(nums[i] + nums[j] + nums[k] == <span class="hljs-number">0</span>)<br>                res.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最大子数组和-53"><a href="#最大子数组和-53" class="headerlink" title="最大子数组和(53)"></a>最大子数组和(<a href="https://leetcode.cn/problems/maximum-subarray/description/">53</a>)</h2><p>动态规划即可，并且不需要dp数组，只需要一个值来保存到当前位置子序列的最大值，如果加上nums[i]还比nums[i]小的话，那dp就等于nums[i]，每轮结束后选择最大的dp作为res。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> dp = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> res = dp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(dp + nums[i] &lt; nums[i])  dp = nums[i];<br>            <span class="hljs-keyword">else</span>    dp = dp + nums[i];<br>            res = <span class="hljs-built_in">max</span>(res, dp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="排序数组（手撕快排）-912"><a href="#排序数组（手撕快排）-912" class="headerlink" title="排序数组（手撕快排）(912)"></a>排序数组（手撕快排）(<a href="https://leetcode.cn/problems/sort-an-array/description/">912</a>)</h2><p>纯在练手撕快排，把acwing的模版默一下。确实好写</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//还有一种用partition的，但是会超时。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l ,<span class="hljs-type">int</span> r)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = nums[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span>( i &lt; j)&#123;<br>            <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(nums[i] &lt; x);<br>            <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(nums[j] &gt; x);<br>            <span class="hljs-keyword">if</span>(i &lt; j)   <span class="hljs-built_in">swap</span>(nums[i],nums[j]);<br>        &#125;<br>        <span class="hljs-built_in">quickSort</span>(nums, l ,j);<br>        <span class="hljs-built_in">quickSort</span>(nums, j+<span class="hljs-number">1</span>, r);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">quickSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="合并两个有序链表-21"><a href="#合并两个有序链表-21" class="headerlink" title="合并两个有序链表(21)"></a>合并两个有序链表(<a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21</a>)</h2><p>跟归并排序的思想一样，这里主要是要自己创建一个假的头节点，之后就跟merge一模一样了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>            <span class="hljs-comment">//mergesort</span><br>        <span class="hljs-keyword">auto</span> dummy  = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), tail = dummy;<br>        <span class="hljs-keyword">while</span>(list1 &amp;&amp; list2)&#123;<br>            <span class="hljs-keyword">if</span>(list1-&gt;val  &lt; list2-&gt;val)&#123;<br>                tail = tail-&gt;next = list1;<br>                list1 = list1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                tail = tail-&gt;next = list2;<br>                list2 = list2-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(list1)   tail-&gt;next = list1;<br>        <span class="hljs-keyword">if</span>(list2)   tail-&gt;next = list2;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="两数之和-1"><a href="#两数之和-1" class="headerlink" title="两数之和(1)"></a>两数之和(<a href="https://leetcode.cn/problems/two-sum/">1</a>)</h2><p>经典，使用hash将遍历过的数和下标存起来，遍历后面的数看看target-nums[i]在不在hash表里，在就直接返回，不再就把当前数加进去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">count</span>(target-nums[i]) &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> &#123;i, hash[target-nums[i]]&#125;;<br>            &#125;<br>            hash[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day0</title>
    <link href="/2023/11/30/leetcode_day0/"/>
    <url>/2023/11/30/leetcode_day0/</url>
    
    <content type="html"><![CDATA[<p>重新开启刷题计划，希望能坚持下去。按照codetop的顺序往下刷。</p><p>每日题量不定。包含了题目即leetcode链接。</p><p>不会的题目全部参考的acwing的题解。</p><h2 id="无重复字符的最长子串-3"><a href="#无重复字符的最长子串-3" class="headerlink" title="无重复字符的最长子串(3)"></a>无重复字符的最长子串(<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">3</a>)</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。首先想到了动态规划，dp[i]存放了到第i个数的最长子串，所以计算第i个时候需要从第i-1个点最长中遍历看看有没有重复的，如果有，那dp[i] = i - j。否则dp[i] = dp[i-1] + 1，代码如下：</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            dp[i] = dp[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i - dp[i<span class="hljs-number">-1</span>]; j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(s[j] == s[i])&#123;<span class="hljs-comment">//如果有重复则更改dp[i]</span><br>                    dp[i] = i - j;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; n; i++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>也可以用滑动窗口做，这应该才是这题的标签。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        unordered_set&lt;<span class="hljs-type">char</span>&gt; map;<br>        <span class="hljs-type">int</span> maxlen = <span class="hljs-number">0</span>, start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> end = <span class="hljs-number">0</span>; end &lt; n; end++)&#123;<br>            <span class="hljs-keyword">while</span>(map.<span class="hljs-built_in">count</span>(s[end]) &gt; <span class="hljs-number">0</span>)&#123;<br>                map.<span class="hljs-built_in">erase</span>(s[start]);<br>                start++;<br>            &#125;<br>            map.<span class="hljs-built_in">insert</span>(s[end]);<br>            maxlen = <span class="hljs-built_in">max</span>(maxlen, end - start + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxlen;  <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>不知道为什么用dp做的时间更短点。</p><h2 id="反转链表-206"><a href="#反转链表-206" class="headerlink" title="反转链表(206)"></a>反转链表(<a href="https://leetcode.cn/problems/reverse-linked-list/">206</a>)</h2><p>很简单，注意每次while时先把p的下一个存好。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* q = <span class="hljs-literal">NULL</span>;<br>        ListNode* p = head;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)&#123;<br>            ListNode* r = p-&gt;next; <span class="hljs-comment">// 将p的下一个节点先存下来</span><br>            p-&gt;next = q;<br>            q = p;<br>            p = r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> q;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LRU缓存机制-146"><a href="#LRU缓存机制-146" class="headerlink" title="LRU缓存机制(146)"></a>LRU缓存机制(<a href="https://leetcode.cn/problems/lru-cache/description/">146</a>)</h2><p>设计一个数据结构，满足LRU，使用了双链表加unordered_map;</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<span class="hljs-comment">//双链表节点</span><br>        <span class="hljs-type">int</span> key,val;<br>        Node *left, *right;<br>        <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _val): <span class="hljs-built_in">key</span>(_key), <span class="hljs-built_in">val</span>(_val), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>    &#125;*L,*R;<span class="hljs-comment">//分别指向双链表最左和最右节点</span><br>    unordered_map&lt;<span class="hljs-type">int</span>,Node*&gt; hash;<span class="hljs-comment">//hash表</span><br>    <span class="hljs-type">int</span> n;<span class="hljs-comment">//容量</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node* p)</span></span>&#123;<br>        p-&gt;right-&gt;left = p-&gt;left;<br>        p-&gt;left-&gt;right = p-&gt;right;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Node* p)</span></span>&#123;<span class="hljs-comment">//每次在左边插入</span><br>        p-&gt;right = L-&gt;right;<br>        p-&gt;left = L;<br>        L-&gt;right-&gt;left = p;<br>        L-&gt;right = p;<br>    &#125;<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123;<span class="hljs-comment">//初始化</span><br>        n = capacity;<br>        L = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>), R = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>);<br>        L-&gt;right = R, R-&gt;left = L;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<span class="hljs-comment">//获取完后都将此节点转移到最左边</span><br>        <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">auto</span> p = hash[key];<br>        <span class="hljs-built_in">remove</span>(p);<br>        <span class="hljs-built_in">insert</span>(p);<br>        <span class="hljs-keyword">return</span> p-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">count</span>(key))&#123;<br>            <span class="hljs-keyword">auto</span> p = hash[key];<br>            p-&gt;val = value;<br>            <span class="hljs-built_in">remove</span>(p);<br>            <span class="hljs-built_in">insert</span>(p);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">size</span>() == n)&#123;<span class="hljs-comment">//如果链表满了则移除最近最少使用的节点，即最右端的节点</span><br>                <span class="hljs-keyword">auto</span> p = R-&gt;left;<br>                <span class="hljs-built_in">remove</span>(p);<br>                hash.<span class="hljs-built_in">erase</span>(p-&gt;key);<br>                <span class="hljs-keyword">delete</span> p;<br>            &#125;<br>            <span class="hljs-keyword">auto</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>            hash[key] = p; <br>            <span class="hljs-built_in">insert</span>(p); <br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="数组中的第k个最大数字-215"><a href="#数组中的第k个最大数字-215" class="headerlink" title="数组中的第k个最大数字(215)"></a>数组中的第k个最大数字(<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">215</a>)</h2><p>这题我直接排序可以通过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">return</span> nums[n-k];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但显然不是这么做，这题是想考察分治法求第k大的数，时间复杂度为$O(nlogn)$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(nums, k);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span></span>&#123;<br>        <span class="hljs-type">int</span> pivot = nums[nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>];<br>        vector&lt;<span class="hljs-type">int</span>&gt; big, equal, small;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num: nums)&#123;<br>            <span class="hljs-keyword">if</span>( num &gt; pivot) big.<span class="hljs-built_in">push_back</span>(num);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num == pivot) <br>              equal.<span class="hljs-built_in">push_back</span>(num);<br>            <span class="hljs-keyword">else</span> small.<span class="hljs-built_in">push_back</span>(num);<br>        &#125;<br>        <span class="hljs-keyword">if</span>( k &lt;=big.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(big,k);<br>        &#125;<br>        <span class="hljs-keyword">if</span>( k &gt; nums.<span class="hljs-built_in">size</span>() - small.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(small, k - nums.<span class="hljs-built_in">size</span>() + small.<span class="hljs-built_in">size</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> pivot;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="K个一组反转链表-25"><a href="#K个一组反转链表-25" class="headerlink" title="K个一组反转链表(25)"></a>K个一组反转链表(<a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/">25</a>)</h2><p>一个指针指向k元素之前，</p><p>1.首先判断往后是否有k个元素</p><p>2.交换k个元素， <img src="https://raw.githubusercontent.com/yanzhang404/Image/main/%E6%88%AA%E5%B1%8F2023-11-30%2021.25.24.png" alt="截屏2023-11-30 21.25.24"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next = head;<br>  <span class="hljs-comment">//先创建一个虚拟头节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p = dummy; ;)&#123;<br>          <span class="hljs-comment">//先判断是否够k个，如果不够直接break了</span><br>            <span class="hljs-keyword">auto</span> q = p;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>                q = q-&gt;next;<br>                <span class="hljs-keyword">if</span>(q == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">break</span>;   <br>            &#125;<br>            <span class="hljs-keyword">if</span>(!q) <span class="hljs-keyword">break</span>;<br>          <span class="hljs-comment">//开始反转，这边的abc指针再好好看看</span><br>            <span class="hljs-keyword">auto</span> a = p-&gt;next, b = a-&gt;next;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; i++)&#123;<br>                <span class="hljs-keyword">auto</span> c = b-&gt;next;<br>                b-&gt;next = a;<br>                a = b;<br>                b = c;<br>            &#125;<br>            <span class="hljs-keyword">auto</span> c = p-&gt;next;<br>            p-&gt;next = a, c-&gt;next = b;<br>            p = c; <br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker install and apply</title>
    <link href="/2023/11/20/ubuntu%E5%AE%89%E8%A3%85docker/"/>
    <url>/2023/11/20/ubuntu%E5%AE%89%E8%A3%85docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker安装及使用"><a href="#docker安装及使用" class="headerlink" title="docker安装及使用"></a>docker安装及使用</h1><h2 id="一、ubuntu安装docker"><a href="#一、ubuntu安装docker" class="headerlink" title="一、ubuntu安装docker"></a>一、ubuntu安装docker</h2><p>更新现有的包：</p><p>sudo apt update</p><p>sudo apt upgrade</p><p>使用apt安装允许通过HTTPS才能使用的软件包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install apt-transport-https ca-certificates curl software-properties-common<br><br></code></pre></td></tr></table></figure><p>将官方docker存储库的GPG密匙添加到系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -<br><br></code></pre></td></tr></table></figure><span id="more"></span><p>将DOcker存储库添加到APT源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&quot;<br><br></code></pre></td></tr></table></figure><p>sudo apt update 更新包数据库</p><p>从Docker repo安装，而不是Ubuntu repo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt-cache policy docker-ce<br></code></pre></td></tr></table></figure><p>安装docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install docker-ce<br><br></code></pre></td></tr></table></figure><p>检测docker是否在运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl status docker<br></code></pre></td></tr></table></figure><p>执行docker时不需要输入sudo</p><p>将用户名添加到docker组中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo usermod -aG docker $&#123;USER&#125;<br>su - $&#123;USER&#125;<br><br></code></pre></td></tr></table></figure><h2 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h2><p>docker images</p><p>docker rmi image_ID</p><p>docker rm container_ID</p><p>docker start container_ID</p><p>docker ps -a</p><p>参数：</p><p>-i: 交互</p><p>-t: 终端 ，(-it可连用)</p><p>-d: 默认不进入容器</p><p>-v: 挂载本地目录到容器目录</p><p><strong>根据Dockerfile文件构建iamge</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t image_name:latet .<br></code></pre></td></tr></table></figure><p>-t 为构建的镜像标记名称</p><p>. 代表根据当前目录下的Dockerfile文件生成镜像</p><p><strong>docker删除停止容器的命令</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">docker <span class="hljs-built_in">container</span> prune<br></code></pre></td></tr></table></figure><p>docker查找无标签的镜像：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> images -f <span class="hljs-string">&quot;dangling=true&quot;</span><br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> images -q -f <span class="hljs-string">&quot;dangling=true&quot;</span><br></code></pre></td></tr></table></figure><p>通过以下命令删除无标签的镜像：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">docker <span class="hljs-keyword">image</span> prune -f --<span class="hljs-keyword">filter</span> <span class="hljs-string">&quot;dangling=true&quot;</span><br></code></pre></td></tr></table></figure><p>docker compose实时查看日志：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose logs -f</span><br></code></pre></td></tr></table></figure><p>docker查看容器ip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect -f &#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; 8f9191fe3754(container_id)<br></code></pre></td></tr></table></figure><h2 id="二、Docker部署MySQL"><a href="#二、Docker部署MySQL" class="headerlink" title="二、Docker部署MySQL"></a>二、Docker部署MySQL</h2><h2 id="1-1-创建mysql容器"><a href="#1-1-创建mysql容器" class="headerlink" title="1.1 创建mysql容器"></a>1.1 创建mysql容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">拉取mysql images</span><br>docker pull mysql<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建一个持久化存储卷</span><br>docker volume create mysql-data<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建自定义网络</span><br>docker network create my_network<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行MySQL容器</span><br>docker run --name test-mysql \<br>   --network my_network \<br>   -p 3307:3306 \   #我这3306端口被本地mysql占用，换了个端口<br>   --restart always \<br>   -e MYSQL_ROOT_PASSWORD=123456 \<br>   -e MYSQL_DATABASE=mydatabase \<br>   -v mysql-data:/var/lib/mysql \<br>   --cpus=&quot;.5&quot; \<br>   --memory=&quot;512m&quot; \<br>   -d mysql:latest.  #最新的<br></code></pre></td></tr></table></figure><h2 id="1-2-配置数据库权限"><a href="#1-2-配置数据库权限" class="headerlink" title="1.2 配置数据库权限"></a>1.2 配置数据库权限</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it test-mysql bash<br><br>mysql -u root -p<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入密码后进入mysql命令行</span><br></code></pre></td></tr></table></figure><p>给权限的时候我输入sql语句一直出问题，采用可视化的软件给‘yan‘这个用户所有的权限了。</p><h2 id="1-3-使用容器部署phpMyadmin"><a href="#1-3-使用容器部署phpMyadmin" class="headerlink" title="1.3 使用容器部署phpMyadmin"></a>1.3 使用容器部署phpMyadmin</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name test-phpmyadmin \<br>   --network my_network \<br>   -e PMA_HOST=test-mysql \ #可以填数据库主机名或者ip地址<br>   -p 3309:80 \。 #这里为了统一记忆，选择3309端口<br>   --restart always \<br>   -d  \<br>   phpmyadmin/phpmyadmin:latest<br></code></pre></td></tr></table></figure><p>此时可以使用localhost:3309打开phpMy Admin。输入用户密码可以管理数据库</p><h2 id="三、docker部署前后端应用"><a href="#三、docker部署前后端应用" class="headerlink" title="三、docker部署前后端应用"></a>三、docker部署前后端应用</h2><h3 id="2-1-Nginx使用"><a href="#2-1-Nginx使用" class="headerlink" title="2.1 Nginx使用"></a>2.1 Nginx使用</h3><p>nginx主要功能有：</p><p><strong>反向代理服务器</strong>：将客户端的请求转发到后端并根据配置将后端的响应返回给客户端。</p><p><strong>URL重写规则</strong>：满足各种重定向、路由和别名需求</p><p><strong>API网关</strong>： 作为API的网关，管理控制API的访问</p><p><strong>负载均衡</strong>：支持多种负载均衡算法，轮询、IP哈希和权重等等。</p><p><strong>高并发连接</strong>：处理百万级的并发连接</p><h3 id="2-2-nginx-配置文件"><a href="#2-2-nginx-配置文件" class="headerlink" title="2.2 nginx 配置文件"></a>2.2 nginx 配置文件</h3><p>通过在本地写配置文件，再映射到容器内，需要修改在本地修改即可。</p><p>在本地创建nginx.conf</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>; <span class="hljs-comment"># Nginx 监听的端口号</span><br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span> /usr/share/nginx/html; <span class="hljs-comment"># 指定网站的根目录</span><br>        <span class="hljs-attribute">index</span> index.html index.htm; <span class="hljs-comment"># 指定默认的首页文件名</span><br>    &#125;<br><br>    <span class="hljs-comment"># 其他 location 块和设置可以根据需要进行添加</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-通过容器运行Nginx反向代理"><a href="#2-3-通过容器运行Nginx反向代理" class="headerlink" title="2.3 通过容器运行Nginx反向代理"></a>2.3 通过容器运行Nginx反向代理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name my-nginx \ # 容器名<br>   -p 3308:80 \ # 将主机的 3308端口映射到容器的 80 端口<br>   -v /path/to/your/nginx.conf:/etc/nginx/conf.d/default.conf \ # 挂载配置文件<br><span class="hljs-meta prompt_">#</span><span class="language-bash">上面的路径填写本地nginx.conf的位置</span><br>   --network my_network \ # 指定网络<br>   --restart always \ # 容器重启策略<br>   -d nginx:latest # 使用 nginx 镜像并在后台运行<br></code></pre></td></tr></table></figure><h3 id="2-4-配置phpMyAdmin转发"><a href="#2-4-配置phpMyAdmin转发" class="headerlink" title="2.4 配置phpMyAdmin转发"></a>2.4 配置phpMyAdmin转发</h3><p>为了访问localhost:3308/phpMyAdmin的时候可以转到后端服务器</p><p>在nginx.conf里加入：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>; <span class="hljs-comment"># Nginx 监听的端口号</span><br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span> /usr/share/nginx/html; <span class="hljs-comment"># 指定网站的根目录</span><br>        <span class="hljs-attribute">index</span> index.html index.htm; <span class="hljs-comment"># 指定默认的首页文件名</span><br>    &#125;<br><br>    <span class="hljs-section">location</span> /phpmyadmin/ &#123; <span class="hljs-comment"># 定义 location 块用于匹配 /phpmyadmin/ 路径</span><br>        <span class="hljs-attribute">proxy_pass</span> http://test-phpmyadmin/; <span class="hljs-comment"># 反向代理到后端服务器</span><br>        <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>; <span class="hljs-comment"># 设置 Host 头字段</span><br>        <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>; <span class="hljs-comment"># 设置真实 IP 头字段</span><br>        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>; <span class="hljs-comment"># 设置 XFF 头字段</span><br>        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Proto <span class="hljs-variable">$scheme</span>; <span class="hljs-comment"># 设置协议头字段</span><br>    &#125;<br><br>    <span class="hljs-comment"># 其他 location 块和设置可以根据需要进行添加</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker restart my-nginx #重启nginx<br></code></pre></td></tr></table></figure><p>再访问</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mit6.s081_2</title>
    <link href="/2023/08/18/mit6.s081_2/"/>
    <url>/2023/08/18/mit6.s081_2/</url>
    
    <content type="html"><![CDATA[<h1 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h1><p>本节视频与书的内容主要讲了操作系统为了保证程序的强隔离性，将硬件资源抽象，禁止程序直接访问硬件，例如程序只通过open，read等系统调用来和存储交互，而不是直接读写磁盘。</p><p>操作系统设置了用户模式和内核模式，内核模式下可以使用所有系统资源，用户通过system call来要求内核为其完成某些操作。</p><p>本章也提出了微内核和宏内核的一些区别。</p><span id="more"></span><h2 id="1-trace"><a href="#1-trace" class="headerlink" title="1. trace"></a>1. trace</h2><p>添加一个系统调用trace，需要一个参数，int型的变量mask，指明了追踪哪个系统调用。</p><p>The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p><p>这个trace系统调用可以追踪调用它的进程以及其fork出来的子进程。</p><ul><li>Add a sys_trace() function in kernel/sysproc.c that <strong>implements the new system call</strong> by <strong>remembering its argument</strong> in a new variable in the proc structure (see kernel/proc.h). The functions to <strong>retrieve system call arguments from user space</strong> are in kernel/syscall.c, and you can see examples of their use in kernel/sysproc.c.</li></ul><p>根据hint一步一步添加</p><p>首先在user/user.h中添加trace(int)</p><p><img title="" src="https://raw.githubusercontent.com/yanzhang404/Image/main/%E6%88%AA%E5%B1%8F2023-08-17%2011.07.20.png" alt="" data-align="center" width="679"></p><p>在user/usys.pl中增加一个stub</p><p><img src="https://raw.githubusercontent.com/yanzhang404/Image/main/%E6%88%AA%E5%B1%8F2023-08-17%2011.07.40.png" title="" alt="" width="688"></p><p>在kernel/syscall.h中增加syscall number</p><p><img src="https://raw.githubusercontent.com/yanzhang404/Image/main/%E6%88%AA%E5%B1%8F2023-08-17%2011.08.17.png" alt=""></p><p>在kernel/sysproc.c里 增加一个sys_trace()，其中利用argint(0,&amp;trace_sys_mask)来从用户程序中获取系统调用的参数，存在trace_sys_mask中</p><p><img src="https://raw.githubusercontent.com/yanzhang404/Image/main/%E6%88%AA%E5%B1%8F2023-08-17%2011.08.09.png" alt=""></p><p>在syscall.c里增加extern uint64 sys_trace(void)</p><p>在静态函数指针数组里增加[SYS_trace]  sys_trace,</p><p><img src="https://raw.githubusercontent.com/yanzhang404/Image/main/%E6%88%AA%E5%B1%8F2023-08-17%2011.08.25.png" alt=""></p><p><img src="https://raw.githubusercontent.com/yanzhang404/Image/main/%E6%88%AA%E5%B1%8F2023-08-17%2014.50.24.png" alt=""></p><p>修改syscall.c中的syscall函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123;<br>    <span class="hljs-comment">//增加一个静态指针数组，内容为系统调用的名称</span><br>   <span class="hljs-type">char</span> <span class="hljs-type">const</span> *syscall_names[] = &#123;<span class="hljs-string">&quot;fork&quot;</span>, <span class="hljs-string">&quot;exit&quot;</span>, <span class="hljs-string">&quot;wait&quot;</span>, <span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>,<br>  <span class="hljs-string">&quot;kill&quot;</span>, <span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-string">&quot;fstat&quot;</span>, <span class="hljs-string">&quot;chdir&quot;</span>, <span class="hljs-string">&quot;dup&quot;</span>, <span class="hljs-string">&quot;getpid&quot;</span>, <span class="hljs-string">&quot;sbrk&quot;</span>, <span class="hljs-string">&quot;sleep&quot;</span>,<br>  <span class="hljs-string">&quot;uptime&quot;</span>, <span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-string">&quot;write&quot;</span>, <span class="hljs-string">&quot;mknod&quot;</span>, <span class="hljs-string">&quot;unlink&quot;</span>, <span class="hljs-string">&quot;link&quot;</span>, <span class="hljs-string">&quot;mkdir&quot;</span>,<span class="hljs-string">&quot;close&quot;</span>,<span class="hljs-string">&quot;trace&quot;</span>,<span class="hljs-string">&quot;sysinfo&quot;</span>&#125;;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  num = p-&gt;trapframe-&gt;a7;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();<br>    <span class="hljs-comment">//判断程序的tracemask的第num位是否为0，不为0则输出信息</span><br>    <span class="hljs-keyword">if</span>(p-&gt;tracemask &amp; (<span class="hljs-number">1</span>&lt;&lt;num))&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_names[num<span class="hljs-number">-1</span>],p-&gt;trapframe-&gt;a0);<br>    &#125;<br>  &#125; <br>  <br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            p-&gt;pid, p-&gt;name, num);<br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改fork，使得child进程复制父进程的mask参数</p><p><img src="https://raw.githubusercontent.com/yanzhang404/Image/main/%E6%88%AA%E5%B1%8F2023-08-17%2011.09.53.png" alt=""></p><p>首先，用户是有一个trace.c的c程序的，而我们在命令行输入trace也是通过这个程序完成的，但执行过程中进行了系统调用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">./grade-lab-syscall trace<br>make: &#x27;kernel/kernel&#x27; is up to date.<br>== Test trace 32 grep == trace 32 grep: OK (1.6s) <br>    (Old xv6.out.trace_32_grep failure log removed)<br>== Test trace all grep == trace all grep: OK (0.7s) <br>    (Old xv6.out.trace_all_grep failure log removed)<br>== Test trace nothing == trace nothing: OK (0.9s) <br>== Test trace children == trace children: OK (11.7s) <br></code></pre></td></tr></table></figure><h2 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><blockquote><p>In this assignment you will add a system call, sysinfo, that <strong>collects information about the running system</strong>. The system call takes one argument: <strong>a pointer to a struct</strong> sysinfo (see kernel/sysinfo.h). The kernel should <strong>fill out the fields</strong> of this struct: the freemem field should be <strong>set to the number</strong> of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints “sysinfotest: OK”.</p></blockquote><p>增加一个系统调用，收集正在运行的系统信息，这个系统调用接受一个参数上指向sysinfo的指针，内核要填充这个结构体，freemem被设成空闲内存的字节数，nproc进程状态UNUSED的进程数量。</p><p>根据提示即可完成，部分操作与trace相同，或者说增加syscall的步骤差不多，比如增加stub、syscall number等等。关键是后面几个hint</p><ul><li><p>sysinfo needs to copy a struct sysinfo back to user space; see sys_fstat() (kernel/sysfile.c) and filestat() (kernel/file.c) for examples of how to do that using copyout().</p></li><li><p>To collect the amount of free memory, add a function to kernel/kalloc.c</p></li><li><p>To collect the number of processes, add a function to kernel/proc.c</p></li></ul><p>为了收集free memory的大小，需要增加一个函数。可以参考kalloc.c中其他函数的实现来完成，函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//collect freemem </span><br>uint64 <br><span class="hljs-title function_">freemem</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  uint64 n = <span class="hljs-number">0</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br>  acquire(&amp;kmem.lock);<br>  r = kmem.freelist; <span class="hljs-comment">//r指向空闲页链表的链表头，往后数即可</span><br>  <span class="hljs-keyword">while</span>(r)&#123;<br>    n++;<br>    r = r-&gt;next;<br>  &#125;<br>  release(&amp;kmem.lock);<br>  <span class="hljs-keyword">return</span> n*PGSIZE; <span class="hljs-comment">//PGSIZE = 4096</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为了得到进程的数量，同样参考proc.c中其他函数的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">//collect the number of processes</span><br>uint64 <br><span class="hljs-title function_">n_proc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>  uint64 nproc = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(p = proc; p &lt;&amp;proc[NPROC];p++)&#123;<br>    acquire(&amp;p-&gt;lock);    <span class="hljs-comment">//不写锁应该也可以的我认为</span><br>    <span class="hljs-keyword">if</span>(p-&gt;state != UNUSED)    <span class="hljs-comment">//如果state不是UNSUSED就n++</span><br>      nproc++;<br>    release(&amp;p-&gt;lock);<br>  &#125;<br>  <span class="hljs-keyword">return</span> nproc;<br>&#125;<br></code></pre></td></tr></table></figure><p>对了这两个函数都要声明一下，它们都是在defs.h中声明的，如图</p><p><img src="https://raw.githubusercontent.com/yanzhang404/Image/main/%E6%88%AA%E5%B1%8F2023-08-18%2019.42.42.png" alt=""></p><p>最后的sysproc.c中添加sysinfo函数,需要参考sys_fstat() (kernel/sysfile.c) and filestat() (kernel/file.c)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">si</span>;</span> <span class="hljs-comment">//这里我一开始写了一个指针，</span><br>                    <span class="hljs-comment">//后面就卡死了，根据copyout的入参这里只是一个结构体</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">my_proc</span> =</span> myproc();<br>  uint64 addr;<br>  <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">0</span>,&amp;addr) &lt;<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  si.freemem = freemem();<br>  si.nproc = n_proc();<br>  <span class="hljs-keyword">if</span>(copyout(my_proc-&gt;pagetable, addr, (<span class="hljs-type">char</span> *)&amp;si, <span class="hljs-keyword">sizeof</span>(si))&lt;<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mit6.s081_1</title>
    <link href="/2023/08/18/mit6.s081_1/"/>
    <url>/2023/08/18/mit6.s081_1/</url>
    
    <content type="html"><![CDATA[<h1 id="（一）qemu环境安装、xv6下载"><a href="#（一）qemu环境安装、xv6下载" class="headerlink" title="（一）qemu环境安装、xv6下载"></a>（一）qemu环境安装、xv6下载</h1><p>没有选择在mac本地写，还是想着在mac上装个虚拟机用linux，于是下载了vmware fushion以及ubuntu server 22.04，服务器版的没有图形化界面也不太想下了，用terminus ssh连上之后安装官网ubuntu的方法配置，但也遇到了qemu版本过高的问题，没办法只能回退版本，跟着知乎大佬重新安装了5.0.1的版本。除了qemu的版本问题，还有一些其他小问题，不过都能解决。环境配置就跟着官网走就好。</p><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">安装工具链</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装5.0.1版本的qemu</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get remove qemu-system-misc</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://download.qemu.org/qemu-5.1.0.tar.xz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar xf qemu-5.1.0.tar.xz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> qemu-5.1.0</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./configure --disable-kvm --disable-werror --prefix=/usr/local --target-list=<span class="hljs-string">&quot;riscv64-softmmu&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo make install</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">克隆xv6仓库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2020</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> xv6-labs-2020</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout util</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进行编译</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make qemu</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">xv6 kernel is booting</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yanzhang404/Image/main/%E6%88%AA%E5%B1%8F2023-07-24%2018.43.01.png" alt="env"></p><h3 id="configure-这里出现了一些error，记录了一下解决方案"><a href="#configure-这里出现了一些error，记录了一下解决方案" class="headerlink" title="./configure 这里出现了一些error，记录了一下解决方案"></a>./configure 这里出现了一些error，记录了一下解决方案</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">1</span><br>ERROR: pkg-config binary &#x27;pkg-config&#x27; not found <br><span class="hljs-meta prompt_">#</span><span class="language-bash">install pkg-config</span><br>~/qemu-5.1.0$ sudo apt install pkg-config<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">2</span><br>ERROR: glib-2.48 gthread-2.0 is required to compile QEMU<br><span class="hljs-meta prompt_"># </span><span class="language-bash">install libglib2.0-dev</span><br>~/qemu-5.1.0$ sudo apt-get install libglib2.0-dev<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">3</span><br>ERROR: pixman &gt;= 0.21.8 not present.<br>       Please install the pixman devel package.<br><span class="hljs-meta prompt_"># </span><span class="language-bash">install libpixman-1-dev</span><br>~/qemu-5.1.0$ sudo apt-get install libpixman-1-dev<br></code></pre></td></tr></table></figure><p>环境配好，开始进入mit6.s081的学习。</p><h1 id="xv6书上内容笔记"><a href="#xv6书上内容笔记" class="headerlink" title="xv6书上内容笔记"></a>xv6书上内容笔记</h1><p>主要的循环利用getcmd来读取用户输入的一行，然后调用fork，创建一个shell程序的副本，父进程调用wait，子进程来运行这个命令。例如，当用户在shell中输入 “ echo hello”，runcmd就会被调用，runcmd会运行这个命令 ，对于echo hello，它会调用exec，如果exec成功，那么子进程会执行echo中的instruction来代替runcmd。在某时，echo会exit，这时父进程会从wait返回。</p><h2 id="fork-exec"><a href="#fork-exec" class="headerlink" title="fork + exec"></a>fork + exec</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-comment">// forkexec.c: fork then exec</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span> <span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> pid, status;<br>    pid = fork();<br>    <span class="hljs-keyword">if</span>(pid ==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">char</span> *argv [] = &#123; <span class="hljs-string">&quot;echo&quot;</span>, <span class="hljs-string">&quot;THIS&quot;</span>, <span class="hljs-string">&quot;IS&quot;</span>, <span class="hljs-string">&quot;ECHO&quot;</span>, <span class="hljs-number">0</span> &#125;;<br>        exec(<span class="hljs-string">&quot;echo&quot;</span>, argv);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exec failed!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span> (<span class="hljs-number">1</span>);    <br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent waiting\n&quot;</span>);<br>        wait (&amp;status);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the child exited with status %d\n&quot;</span>, status);<br>        &#125;    <br>    <span class="hljs-built_in">exit</span> (<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当shell要执行一条命令时，会先fork出一个子进程，由子进程去执行，即代码中pid==0时，子进程执行exec，会替换掉内存中的内容，执行echo，而不会执行下面的exec failed，若exec中是一个不存在的指令，则会执行下面的语句，exit(1)。父进程则会输出parent waiting</p><h2 id="io-redirection"><a href="#io-redirection" class="headerlink" title="io redirection"></a>io redirection</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span> <span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> pid;<br>    pid = fork();<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        close(<span class="hljs-number">1</span>);<br>        open (<span class="hljs-string">&quot;output.txt&quot;</span>, O_WRONLY|O_CREATE);<br>        <span class="hljs-type">char</span> *arg[] = &#123; <span class="hljs-string">&quot;echo&quot;</span>, <span class="hljs-string">&quot;this&quot;</span>, <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;redirected&quot;</span>, <span class="hljs-string">&quot;echo&quot;</span>, <span class="hljs-number">0</span> &#125;;<br>        exec (<span class="hljs-string">&quot;echo&quot;</span>, argv);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exec failed!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span> (<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        wait((<span class="hljs-type">int</span> *) <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h1><p>写lab采用了vscode远程连接到本地虚拟机，很方便。</p><h2 id="1-sleep-c"><a href="#1-sleep-c" class="headerlink" title="1.sleep.c"></a>1.sleep.c</h2><p>为xv6实现一个UNIX程序sleep，sleep要在用户指定的时间内暂停。时间是由xv6核决定的，是定时器芯片两次中断的时间。</p><p>很简单，调用了sleep的system call。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br><br>    <span class="hljs-keyword">if</span>(argc &lt;= <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Error: please input number\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> n = atoi(argv[<span class="hljs-number">1</span>]);<br>    sleep(n);    <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="遇到一个小问题，在使用grade测试的时候，显示："><a href="#遇到一个小问题，在使用grade测试的时候，显示：" class="headerlink" title="遇到一个小问题，在使用grade测试的时候，显示："></a>遇到一个小问题，在使用grade测试的时候，显示：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">~/xv6-labs-2020$ </span><span class="language-bash">./grade-lab-util <span class="hljs-built_in">sleep</span></span><br>/usr/bin/env: ‘python’: No such file or directory<br></code></pre></td></tr></table></figure><p>查了一下解决办法，因为我的ubuntu的是python3，所以创建一个符号链接即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ln -s /usr/bin/python3 /usr/bin/python<br></code></pre></td></tr></table></figure><p>再次测试成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sleep, no arguments: OK (2.1s) <br>== Test sleep, returns == sleep, returns: OK (1.1s) <br>== Test sleep, makes syscall == sleep, makes syscall: OK (1.0s) <br></code></pre></td></tr></table></figure><h2 id="2-pingpong-c"><a href="#2-pingpong-c" class="headerlink" title="2. pingpong.c"></a>2. pingpong.c</h2><p>这题我理解为要设两个管道，因为子进程和父进程都要写和读，后来参考其他答案时有写两个的也有只需要写一个即可的，因此学习了1个pipe的解答。这题虽然是easy，但因为一些前置知识可能掌握的不好，查了很久资料才回来写，且刚开始写明显不熟悉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<span class="hljs-comment">//</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">2</span>];<span class="hljs-comment">//缓冲区，只需要写入1byte</span><br>    pipe(p); <span class="hljs-comment">//创建管道，p[0]读，p[1]写</span><br>    <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> pid = getpid();<br>        <span class="hljs-keyword">if</span>(read(p[<span class="hljs-number">0</span>],buf,<span class="hljs-number">1</span>) !=<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//</span><br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;ERROR\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);    <br>        &#125;<br>        close(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">//读完关闭读端</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received ping\n&quot;</span>,pid);<br>        <span class="hljs-keyword">if</span>(write(p[<span class="hljs-number">1</span>],buf,<span class="hljs-number">1</span>)!=<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;ERROR\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> pid = getpid();<br>        <span class="hljs-keyword">if</span>(write(p[<span class="hljs-number">1</span>],buf,<span class="hljs-number">1</span>)!=<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;ERROR\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        close(p[<span class="hljs-number">1</span>]);<br>        wait(<span class="hljs-number">0</span>); <span class="hljs-comment">//需要等待子进程读到数据，这个没想到</span><br>        <span class="hljs-keyword">if</span>(read(p[<span class="hljs-number">0</span>],buf,<span class="hljs-number">1</span>)!=<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;ERROR\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received pong\n&quot;</span>, pid);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后测试OK</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">./grade-lab-util pingpong<br>make: &#x27;kernel/kernel&#x27; is up to date.<br>== Test pingpong == pingpong: OK (1.3s) <br></code></pre></td></tr></table></figure><h2 id="3-primes-c"><a href="#3-primes-c" class="headerlink" title="3. primes.c"></a>3. primes.c</h2><p>本题已经把我难到，主要是对pipe的理解还不到位，查阅了一些资料，以及其他人的解法，理解了之后自己写了一下。也成功了。</p><p>本题查看了题目所提供的文档<a href="[Lab: Xv6 and Unix utilities](https://pdos.csail.mit.edu/6.S081/2021/labs/util.html">Bell Labs and CSP Threads</a>) ，了解了埃式素数筛的原理，需要用pipe+fork来实现下面的伪代码：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">p = <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span> <span class="hljs-built_in">from</span> left neighbor<br>print p<br>loop:<br>    n = <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">number</span> <span class="hljs-built_in">from</span> left neighbor<br>    <span class="hljs-keyword">if</span> (p does <span class="hljs-keyword">not</span> <span class="hljs-built_in">divide</span> n)<br>        <span class="hljs-built_in">send</span> n <span class="hljs-built_in">to</span> <span class="hljs-literal">right</span> neighbor<br></code></pre></td></tr></table></figure><p>可以利用递归，不断的在子进程中创建子进程，直到将管道中的数都读完。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">child</span><span class="hljs-params">(<span class="hljs-type">int</span> listenfd)</span>&#123;<span class="hljs-comment">//传入管道端读端</span><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//在子进程中执行此函数</span><br>    <span class="hljs-type">int</span> re = read(listenfd,&amp;num,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)); <br>    <span class="hljs-keyword">if</span>(re == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果全部读完了就退出</span><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<span class="hljs-comment">//子进程创建管道，此时子进程作为主进程</span><br>    pipe(p);<br>    <span class="hljs-type">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(!pid)&#123;<span class="hljs-comment">//在主进程中</span><br>        close(p[<span class="hljs-number">0</span>]);<span class="hljs-comment">//关闭新管道的读端</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, num);<span class="hljs-comment">//输出读到的第一个数字</span><br>        <span class="hljs-type">int</span> n = num;<br>        <span class="hljs-keyword">while</span>(read(listenfd,&amp;num,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))!=<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//不断的从左管道读入数字</span><br>            <span class="hljs-keyword">if</span>(num % n)&#123;<span class="hljs-comment">//如果能整除，就传入新的管道</span><br>                write(p[<span class="hljs-number">1</span>],&amp;num,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>            &#125;<br>        &#125;<br>        close(p[<span class="hljs-number">1</span>]);<span class="hljs-comment">//关闭写端</span><br>        wait(<span class="hljs-number">0</span>);<span class="hljs-comment">//等待子进程</span><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        close(p[<span class="hljs-number">1</span>]);<span class="hljs-comment">//关闭写端 否则文件描述符不够</span><br>        child(p[<span class="hljs-number">0</span>]);<span class="hljs-comment">//递归，再对读端调用函数</span><br>        close(p[<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argv, <span class="hljs-type">char</span> *argc[])</span>&#123;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<span class="hljs-comment">//设一个管道</span><br>    pipe(p);<br>    <span class="hljs-type">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(!pid)&#123; <span class="hljs-comment">//如果是主进程，则把2到35全部写入管道中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i&lt;=<span class="hljs-number">35</span>;i++)&#123;<br>            write(p[<span class="hljs-number">1</span>],&amp;i,<span class="hljs-number">4</span>);<br>        &#125;<br>        close(p[<span class="hljs-number">1</span>]);<span class="hljs-comment">//关闭写端</span><br>        wait(<span class="hljs-number">0</span>); <span class="hljs-comment">//等待子进程结束</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        close(p[<span class="hljs-number">1</span>]); <span class="hljs-comment">//子进程不需要用到写端</span><br>        child(p[<span class="hljs-number">0</span>]);<span class="hljs-comment">//对读端调用函数</span><br>        close(p[<span class="hljs-number">0</span>]);<span class="hljs-comment">//关闭读端</span><br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-find-c"><a href="#4-find-c" class="headerlink" title="4. find.c"></a>4. find.c</h2><p>本题hint查看ls.c来学习如何对目录文件进行遍历，稍微修改即是find的答案，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> T_DIR:<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(path) + <span class="hljs-number">1</span> + DIRSIZ + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">sizeof</span> buf)&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ls: path too long\n&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">strcpy</span>(buf, path);<br>    p = buf+<span class="hljs-built_in">strlen</span>(buf);<br>    *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>    <span class="hljs-keyword">while</span>(read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))&#123;<br>      <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">continue</span>;<br>      memmove(p, de.name, DIRSIZ);<br></code></pre></td></tr></table></figure><p>在ls.c中，若fd指向一个目录，则可以利用每次读一个目录大小的bytes来遍历目录。</p><p>find代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><br><span class="hljs-comment">//find传入的参数是要查找的目录和要查找的文件</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *file)</span>&#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;  <span class="hljs-comment">//缓存区，一个指针</span><br>  <span class="hljs-type">int</span> fd; <span class="hljs-comment">//file discriptor</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span> <span class="hljs-comment">// 一个目录项的结构体</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span> <span class="hljs-comment">//一个文件属性的结构体</span><br>  <span class="hljs-comment">//fd打开path，st是path文件的属性</span><br>  <span class="hljs-keyword">if</span>((fd = open(path, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find cannot open %s\n&quot;</span>, path);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find cannot stat %s\n&quot;</span>,path);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">//因为已经有path了，直接添加到buf中</span><br>  <span class="hljs-built_in">strcpy</span>(buf, path);<br>  p = buf + <span class="hljs-built_in">strlen</span>(buf);<br>  *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>  <span class="hljs-comment">//一开始传入的路径肯定是一个目录，因此对目录循环读取一个de</span><br>  <span class="hljs-keyword">while</span>(read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))&#123;<br>    <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">continue</span>;<br>    memmove(p, de.name, DIRSIZ);<br>    p[DIRSIZ] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find : cannot stat %s\n&quot;</span>, buf);<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-comment">//添加完后，开始将读到的文件与file进行对比</span><br>    <span class="hljs-keyword">switch</span> (st.type)<br>    &#123;<br>    <span class="hljs-keyword">case</span> T_FILE:<br>      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(de.name,file) == <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,buf);<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> T_DIR:<br>      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;.&quot;</span>) &amp;&amp; <span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;..&quot;</span>))<br>        find(buf, file);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  close(fd); <span class="hljs-comment">//及时关闭fd</span><br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span>&#123;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)&#123;<br>      find(<span class="hljs-string">&quot;.&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">3</span>)&#123;<br>      find(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>]);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;ERROR\n&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-xargs-c"><a href="#5-xargs-c" class="headerlink" title="5. xargs.c"></a>5. xargs.c</h2><p>将标准输入的的内容作为xargs后面的命令的参数，核心思想是重新设置新的参数数组，利用fork+exec来执行命令。代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 32</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span>&#123;<br>    <span class="hljs-type">char</span> buf[MAXSIZE];<br>    read(<span class="hljs-number">0</span>, buf, MAXSIZE); <span class="hljs-comment">//从标准输入读到缓冲区</span><br><br><br>    <span class="hljs-type">char</span>* xargv[MAXARG];<br>    <span class="hljs-type">int</span> xargc=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; i++)&#123; <span class="hljs-comment">// 新的参数</span><br>        xargv[xargc++] = argv[i];<br>    &#125;<br><br>    <span class="hljs-type">char</span> *p = buf;<span class="hljs-comment">//指针指向缓冲区</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; MAXSIZE; i++)&#123;<br>        <span class="hljs-keyword">if</span>(buf[i] == <span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>            <span class="hljs-type">int</span> pid = fork();<br>            <span class="hljs-keyword">if</span>( pid == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//child</span><br>                buf[i] = <span class="hljs-number">0</span>;<br>                xargv[xargc] = p;<br>                xargc++;<br>                xargv[xargc] = <span class="hljs-number">0</span>;<br>                exec(xargv[<span class="hljs-number">0</span>], xargv); <span class="hljs-comment">//执行新的命令</span><br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                p = &amp;buf[i+<span class="hljs-number">1</span>]; <span class="hljs-comment">//父进程修改p指针的地址到下一个参数</span><br>                wait(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    wait(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>   基础太差导致花了很久才写完lab1，但也学到了很多。</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my first article</title>
    <link href="/2023/07/20/my-first-article/"/>
    <url>/2023/07/20/my-first-article/</url>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Hello, my name is Zhangyan. I am 23 years old.</p><p>I just graduated from the School of Mathematical Sciences, Soochow University and I will go to study software engineering at the School of Software and Microelectronics, Peking University.</p><span id="more"></span><p>This is my first article.</p><p>Later, maybe I will record my daily life in Beijing and what I learned in programming, and I will try to put some photos here.</p><p>It makes me feel good to have this blog. That’s all. Bye!</p>]]></content>
    
    
    <categories>
      
      <category>thought</category>
      
    </categories>
    
    
    <tags>
      
      <tag>intro</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
